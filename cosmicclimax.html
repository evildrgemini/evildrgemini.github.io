<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Climax Crusaders - Deluxe Mk II</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.css">
    <style>
        /* --- Styles Updated for Retro-Futuristic Erotic Space Theme --- */
        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1a2a4f 0%, #2d3d6a 50%, #4a5b8a 100%);
            color: #e2e8f0;
            margin: 0;
            padding: 0;
            padding-bottom: 150px; /* Ensure space for footer */
        }

        /* Header Styling */
        .site-header { padding: 0; margin-bottom: 1rem; text-align: center; position: relative; overflow: hidden; }
        .header-banner-image { width: 100%; height: 120px; object-fit: cover; display: block; opacity: 0.7; filter: contrast(1.1) saturate(1.2); }
        .site-header h1 { font-family: 'Orbitron', sans-serif; font-size: 2.6rem; color: #f59e0b; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7); margin: 0; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; padding: 0 1rem; box-sizing: border-box; background: rgba(15, 23, 42, 0.6); padding-top: 0.4rem; padding-bottom: 0.4rem; }

        /* Footer Styling */
        .site-footer {
            margin-top: 2rem; padding: 1.5rem 1rem; text-align: center; font-size: 0.875rem; color: #94a3b8; border-top: 1px solid #334155; background-color: rgba(15, 23, 42, 0.8); /* Slightly less transparent */
            position: fixed; /* Fixed footer */
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 10; /* Ensure footer is above body content */
        }
        .footer-buttons { display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; margin-bottom: 1rem; }
        #clipboardMessage { font-size: 0.8rem; color: #f43f5e; height: 1.2em; font-weight: 600; margin-bottom: 1rem; }

        /* Game Layout */
        #game-container { display: flex; flex-direction: column; max-width: 1200px; margin: 0 auto; padding: 0 1rem; gap: 1rem; }

        /* --- NEW: Persistent UI Area --- */
        #persistent-ui-area {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Responsive columns */
            gap: 1rem;
            margin-bottom: 1rem;
            position: sticky; /* Sticky under header? */
            top: 0; /* Stick to top */
            background: rgba(26, 42, 79, 0.9); /* Match body gradient */
            padding: 0.75rem;
            border-radius: 0 0 0.75rem 0.75rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 5; /* Below footer, above turn content */
            border: 1px solid #334155;
        }
        .persistent-card {
            background-color: rgba(30, 41, 59, 0.7); /* Slightly different background */
            color: #cbd5e1;
            border: 1px solid #475569;
            border-radius: 0.5rem; /* Smaller radius */
            padding: 0.75rem 1rem; /* Less padding */
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            font-size: 0.9rem; /* Slightly smaller font */
        }
        .persistent-card h3 {
            font-family: 'Orbitron', sans-serif;
            color: #67e8f9;
            border-bottom: 1px solid #22d3ee;
            padding-bottom: 0.4rem;
            margin-bottom: 0.6rem;
            font-size: 1.1rem;
            font-weight: 600;
        }
        .persistent-card ul { list-style: none; padding: 0; margin: 0; }
        .persistent-card li { margin-bottom: 0.3rem; }
        .persistent-card strong { color: #f59e0b; }
        .persistent-card progress { height: 0.5rem; accent-color: #f472b6; } /* Match slider? */
        .persistent-card .status-item { display: flex; justify-content: space-between; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;}
        .persistent-card .status-label { font-weight: 600; color: #a3e635; } /* Lime green label */
        .persistent-card .status-value { text-align: right; }
        /* --- End NEW Persistent UI --- */


        /* Card Styling (Main Turn Content) */
        .space-card { background-color: rgba(30, 41, 59, 0.85) !important; color: #cbd5e1; border: 1px solid #475569; border-radius: 0.75rem; padding: 1.5rem; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); margin-bottom: 1.5rem; }
        .space-card h2 { font-family: 'Orbitron', sans-serif; color: #67e8f9; border-bottom: 2px dashed #22d3ee; padding-bottom: 0.6rem; margin-bottom: 1.2rem; font-size: 1.6rem; font-weight: 700; text-align: center; flex-shrink: 0; }
        .space-text { color: inherit; line-height: 1.7; word-wrap: break-word; font-size: 1rem; }
        .space-text strong { color: #f59e0b; font-weight: 700; } .space-text em { color: #a3e635; font-style: italic; }
        .space-text pre { background-color: #0f172a; padding: 0.8rem; border-radius: 0.5rem; overflow-x: auto; font-family: 'Courier New', Courier, monospace; font-size: 0.85rem; color: #93c5fd; margin-top: 0.5rem; border: 1px solid #1e293b; }

        /* Inputs */
        .space-input, .space-textarea { width: 100%; padding: 0.8rem; border: 1px solid #475569; border-radius: 0.5rem; color: #e2e8f0; background-color: #1e293b; font-family: 'Roboto', sans-serif; margin-bottom: 0.5rem; }
        .space-input::placeholder, .space-textarea::placeholder { color: #64748b; opacity: 0.7; }
        .space-input:focus, .space-textarea:focus { outline: none; border-color: #22d3ee; box-shadow: 0 0 0 3px rgba(34, 211, 238, 0.3); background-color: #0f172a; }
        .space-textarea { min-height: 70px; }

        /* Radio/Checkbox Options */
        .space-radio-option, .space-checkbox-option { display: flex; align-items: center; margin-bottom: 0.6rem; padding: 0.7rem 1rem; border-radius: 0.75rem; cursor: pointer; transition: background-color 0.2s, transform 0.1s; border: 1px solid #334155; color: inherit; background-color: rgba(15, 23, 42, 0.8); }
        .space-radio-option:hover, .space-checkbox-option:hover { background-color: #1e293b; border-color: #475569; }
        .space-radio-option input[type="radio"], .space-checkbox-option input[type="checkbox"] { margin-right: 0.8rem; cursor: pointer; accent-color: #f59e0b; width: 1.1rem; height: 1.1rem; flex-shrink: 0; }
        .space-radio-option label, .space-checkbox-option label { color: inherit; flex-grow: 1; cursor: pointer; font-weight: 600; }
        .space-radio-option label, .space-checkbox-option label { display: flex; align-items: center; width: 100%; }

        /* Sliders */
        .space-slider { width: 100%; cursor: pointer; accent-color: #f472b6; height: 0.6rem; background: #475569; border-radius: 9999px; appearance: none; -webkit-appearance: none; }
        .space-slider::-webkit-slider-thumb { appearance: none; -webkit-appearance: none; width: 1.3rem; height: 1.3rem; background: var(--slider-thumb-color, #f59e0b); border-radius: 50%; cursor: pointer; border: 2px solid #0f172a; box-shadow: 0 1px 3px rgba(0,0,0,0.4); }
        .space-slider::-moz-range-thumb { width: 1.3rem; height: 1.3rem; background: var(--slider-thumb-color, #f59e0b); border-radius: 50%; cursor: pointer; border: 2px solid #0f172a; box-shadow: 0 1px 3px rgba(0,0,0,0.4); }
        .space-slider-value-display { color: #f59e0b; font-weight: 700; min-width: 2rem; text-align: right; }

        /* Images */
        .space-image-container { margin-bottom: 1rem; text-align: center; }
        .space-image { max-width: 100%; height: auto; border-radius: 0.75rem; background-color: #1e293b; display: block; margin-left: auto; margin-right: auto; border: 2px solid #475569; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); }
        .space-image-prompt { font-size: 0.8rem; color: #67e8f9; opacity: 0.9; font-style: italic; margin-top: 0.5rem; word-wrap: break-word; padding: 0 0.5rem; font-weight: 600; }
        .space-image-label { font-size: 0.9rem; font-weight: 700; color: #a3e635; margin-bottom: 0.3rem; }

        /* Buttons */
        .space-button {
            padding: 0.8rem 1.8rem; background: linear-gradient(to right, #f59e0b, #fbbf24); color: #1e293b; border: none; border-radius: 0.75rem; font-weight: 700; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.3); text-transform: uppercase; letter-spacing: 0.08em; white-space: nowrap; font-size: 0.9rem; font-family: 'Orbitron', sans-serif;
        }
        .space-button:hover { background: linear-gradient(to right, #d97706, #f59e0b); box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.4); transform: translateY(-2px) scale(1.03); }
        .space-button:active { transform: translateY(0) scale(1); box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3); }
        .space-button:disabled { background: #475569; color: #94a3b8; cursor: not-allowed; opacity: 0.7; box-shadow: none; transform: none; }
        #modeToggleButton { background: linear-gradient(to right, #10b981, #22d3ee); } /* Emerald/Cyan */
        #modeToggleButton.red-alert-mode { background: linear-gradient(to right, #f43f5e, #ef4444); } /* Rose/Red */
        #resetGameButton { background: linear-gradient(to right, #ef4444, #dc2626); } /* Red */

        /* Loading/Error */
        .loading-indicator, .error-message { display: flex; justify-content: center; align-items: center; padding: 1rem; font-size: 1rem; border-radius: 0.75rem; margin-top: 1rem; font-weight: 600; }
        .loading-indicator { color: #67e8f9; background-color: #1e293b; border: 1px solid #475569; }
        .loading-indicator svg { width: 1.25rem; height: 1.25rem; color: #22d3ee; }
        .error-message { color: #fecdd3; background-color: #9f1239; border: 1px solid #fb7185; text-align: center; white-space: pre-wrap; }

        /* API Key Section */
        #apiKeySection { margin-bottom: 1rem; background: rgba(30, 41, 59, 0.6); padding: 1rem; border-radius: 0.75rem; border: 1px solid #475569; }
        #apiKeySection .api-key-label { color: #67e8f9; display: block; margin-bottom: 0.6rem; font-weight: 700; font-size: 1rem; font-family: 'Orbitron', sans-serif;}
        #apiKeySection .api-key-instructions span { color: #94a3b8; }
        #apiKeySection .api-key-instructions a { color: #f59e0b; text-decoration: underline; font-weight: 600; }
        #apiKeySection .api-key-instructions a:hover { color: #fbbf24; }

        /* Creative UI Elements (Adapted) */
        .space-toggle-switch { display: inline-flex; align-items: center; cursor: pointer; margin-top: 0.5rem; margin-bottom: 0.5rem; }
        .space-toggle-switch input { display: none; }
        .space-toggle-switch .switch-bg { width: 50px; height: 26px; background-color: #475569; border-radius: 13px; position: relative; transition: background-color 0.3s ease; border: 1px solid #64748b; flex-shrink: 0; }
        .space-toggle-switch .switch-handle { width: 22px; height: 22px; background-color: #cbd5e1; border-radius: 50%; position: absolute; top: 1px; left: 2px; transition: transform 0.3s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .space-toggle-switch input:checked + .switch-bg { background-color: #10b981; /* Emerald */ }
        .space-toggle-switch input:checked + .switch-bg .switch-handle { transform: translateX(24px); }
        .space-toggle-switch span { margin-left: 0.5rem; font-weight: 600; color: #a3e635; /* Lime */ }

        .space-segmented-control { display: flex; border: 1px solid #475569; border-radius: 0.75rem; overflow: hidden; background-color: #1e293b; margin-top: 0.5rem; margin-bottom: 0.5rem; }
        .space-segmented-control label { flex: 1; text-align: center; padding: 0.5rem 0.8rem; cursor: pointer; transition: background-color 0.2s, color 0.2s; font-weight: 600; color: #94a3b8; font-size: 0.9rem; font-family: 'Orbitron', sans-serif; }
        .space-segmented-control input[type="radio"] { display: none; }
        .space-segmented-control input[type="radio"]:checked + label { background-color: #f59e0b; color: #0f172a; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); }
        .space-segmented-control label:not(:last-child) { border-right: 1px solid #475569; }
    </style>
</head>
<body class="bg-slate-900 text-slate-300">

<header class="site-header">
    <img id="headerBanner" alt="Retro Sci-Fi Space Banner" class="header-banner-image">
    <h1>Cosmic Climax Crusaders</h1> </header>

<div class="max-w-6xl mx-auto px-4 md:px-8">
    <div id="apiKeySection">
        <label for="apiKeyInput" class="api-key-label api-key-instructions">
            Enter Google AI API Key to Engage Warp Drive! 🚀
            <span class="block text-sm font-normal mt-1">
                (Get a key from Google AI Studio:
                <a href="https://aistudio.google.com/apikey" target="_blank" rel="noopener noreferrer">
                    aistudio.google.com/apikey
                </a>)
                <br>Or provide via URL: ?apiKey=YOUR_API_KEY
            </span>
        </label>
        <input type="password" id="apiKeyInput" class="space-input" placeholder="Paste your stardrive key here... ✨">
    </div>

    <div id="persistent-ui-area" style="display: none;"> <div id="persistent-status" class="persistent-card">
        <h3>🚀 Ship Status</h3>
        <ul>
        </ul>
    </div>
        <div id="crew-roster" class="persistent-card">
            <h3>🧑‍🚀 Crew Roster</h3>
            <ul>
                <li>No crew data available.</li>
            </ul>
        </div>
        <div id="inventory-display" class="persistent-card">
            <h3>🎒 Inventory</h3>
            <ul>
                <li>Pockets feel disturbingly empty.</li>
            </ul>
        </div>
    </div>
    <div id="game-container">
        <div id="turn-content">
            <div id="initial-message" class="text-center text-cyan-400 p-4 font-semibold space-card">
                Feed the API Key into the console and hit "Engage!" to start your questionable voyage.
            </div>
        </div>

        <div id="loading" class="loading-indicator" style="display: none;">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none"
                 viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span id="loading-message">Calculating dubious trajectories... Please wait! 😵‍💫</span>
        </div>
        <div id="error-display" class="error-message" style="display: none;"></div>

        <div class="mt-6 text-center">
            <button id="submit-turn-button" class="space-button" disabled>
                Engage!
            </button>
        </div>
    </div>
</div>

<footer class="site-footer">
    <div class="footer-buttons">
        <button id="saveGameButton" class="space-button" disabled>Save Progress</button>
        <button id="modeToggleButton" class="space-button standard-mode">Mode: Standard Operations</button>
        <button id="resetGameButton" class="space-button" disabled>Abandon Ship</button>
    </div>
    <div id="clipboardMessage"></div> <div class="footer-content">
    <span>Delivering disappointment across the galaxy &copy; 3025</span>
</div>
</footer>

<script type="module">
    // --- Prompts (Updated for State/Crew/Inventory Awareness & Specific Image URL) ---
    const spaceOperaPrompts = {
        redAlertRomanceAddendum: `**RED ALERT ROMANCE MODE OVERRIDE:**\n\n* **Core Concept:** OVERRIDE 'Standard Operations' Mode. Intensify focus on sensual encounters, suggestive situations, workplace tension/flirtation, and explicit (softcore-style) eroticism, all filtered through a comedic, retro-futuristic lens. Generate scenarios involving close encounters, revealing uniform malfunctions, seductive aliens/crewmates (referencing \`gameState.crew\` and \`gameState.profile.orientation\`), questionable 'diplomatic missions', exploring desires, navigating love triangles, or dealing with malfunctioning 'pleasure-bots'. Aim for high levels of titillation, humor, and slightly absurd sensuality.\n* **Player Profiling & Crew Interaction:** USE the player's profile (\`gameState.profile\`) and existing crew relationships (tracked in \`internalState\`) to tailor romantic/erotic encounters, character dialogue, and potential partners. Ensure encounters align with the player's stated interests AND the defined crew members. Allow choices that improve/damage relationships.\n* **Presentation Style (HTML):** Generate richer, more suggestive HTML. Use warmer colors or dramatic reds/pinks via inline styles or Tailwind classes where appropriate for mood. Visuals (\`<img>\`) should depict suggestive poses, alluring aliens/robots/crewmates (based on \`gameState.crew\`), dimly lit environments, partial nudity (tasteful, pin-up style, within API limits), intense gazes, or comedic juxtapositions of sci-fi and sensuality. **Use the required URL format: \`https://image.pollinations.ai/prompt/{GENERATED_PROMPT}?width={WIDTH}&height={HEIGHT}&seed={RANDOM_SEED}&nologo=true&safe=false\`**. Generate relevant \`{GENERATED_PROMPT}\` text, choose appropriate \`{WIDTH}\` and \`{HEIGHT}\` (e.g., 368x448), and use a random \`{RANDOM_SEED}\`.** Text uses more flirtatious, suggestive language.\n* **Encounters & Choices (HTML - Creative & Profile/Crew-Aware):** Generate encounters focused on romantic/sexual tension or explicit softcore situations, informed by the player's profile and potentially involving specific crew members. Choices are HTML form elements within \`<form id='space-opera-turn-form'>\`. VARY UI elements. Options involve expressing desire towards specific crew members, navigating risky romantic situations, or engaging in sensual activities. Choices significantly impact 'Heat' level, 'Morale', relationship status with crew (update in \`internalState\`), and potentially earn/spend 'Spice Credits'.\n* **Multi-Image Generation (HTML):** Generate 2-5 images per turn using standard \`<img>\` tags with the required Pollinations.ai URL format, reflecting the Red Alert theme and potentially depicting crew members in suggestive scenarios.\n* **Analyses (Internal):** 'internalState' logs relationship developments, choices involving crew, and player's romantic/sexual choices. 'gemini_facing_analysis' summarizes the player's 'type' and romantic strategy, potentially mentioning crew interactions. Player-facing analysis might offer cheeky advice about crew or the rising 'Heat' level.\n* **Status Impact:** Erotic events heavily influence 'Heat', 'Morale', and 'Relationship Status' with involved crew. 'Spice Credits' might be earned/spent. **NOTE:** Status display is handled by client JS, but the AI should still generate status changes to be logged in \`internalState\` and parsed by the client.\n`,

        firstrun: `**Instructions for Generating Turn 1 ONLY (Cosmic Climax Crusaders - HTML Output):**\n\n**(Input: None. Output: Raw HTML snippet for Turn 1 Space Opera UI)**\n\n* **Goal:** Generate the initial HTML state for the \`#turn-content\` div. Introduce the premise, perform player profiling, and establish initial state.\n* **Theme:** Comedic Erotic Retro-Futuristic Space Opera. Start in 'Standard Operations' mode.\n* **Output Format:** Raw HTML content block for \`#turn-content\`.\n* **HTML Structure Requirements:**\n    * Use Tailwind & custom classes (\`.space-card\`, \`.space-button\`, etc.).\n    * Include sections for Status (within the turn card for now), Event Description, Images, and Player Choices/Profiling.\n    * **Status (Generated in Turn Card):** Display initial values (e.g., Fuel: 80/100 ⛽, Morale: 50/100 😬, Clankiness: 30/100 🔩, Heat: 10/100 🔥, Spice Credits: 0 🌶️) using text, icons, maybe progress bars within a \`.space-card\` in the generated HTML. (Client JS handles the *persistent* display separately).\n    * **Event:** Title ("Awake in the Junk Bucket!") and description.\n    * **Images:** Generate 2-3 images using \`<img>\` tags. **CRITICAL: Use the Pollinations.ai URL format:** \`https://image.pollinations.ai/prompt/{GENERATED_PROMPT}?width={WIDTH}&height={HEIGHT}&seed={RANDOM_SEED}&nologo=true&safe=false\`. Generate relevant \`{GENERATED_PROMPT}\` text, choose appropriate \`{WIDTH}\` and \`{HEIGHT}\` (e.g., 368x448 or similar), and use a random \`{RANDOM_SEED}\`. Include a \`.space-image-prompt\` div below each image showing the \`{GENERATED_PROMPT}\` used.\n    * **Choices & Profiling:** Wrap choices in \`<form id=\"space-opera-turn-form\">\`. Include initial profiling questions (Species, Attraction, Motivation, Role) using VARIED UI elements (segmented controls, checkboxes, sliders, inputs).\n    * **Initial Action:** Include a simple starting action choice.\n    * **Hidden Fields:** CRITICAL - Include hidden inputs: \`<input type='hidden' name='turn' value='1'>\`, \`<input type='hidden' name='subjectId' value='Crewmate'>\`, \`<input type='hidden' name='internalState' value='{initial_escaped_markdown_state}'>\`.\n    * **No Submit Button:** DO NOT include \`#submit-turn-button\` in the generated HTML.\n* **Internal State (For Hidden Field):** Generate initial JSON-escaped Markdown. Include placeholders for profile, initial status, empty crew/inventory. Example structure:\n\`\`\`markdown\n# Captain's Log - Stardate ?? - Turn 1\n\n* **Subject:** Crewmate\n* **Mode:** Standard Operations\n* **Initial Status:** Fuel 80, Morale 50, Clankiness 30, Heat 10, SpiceCredits 0\n* **Player Profile:** { "species": "unspecified", "role": "unspecified", "orientation": "unspecified", "preferences": [], "motivation": "unspecified" }\n* **Crew Roster:** []\n* **Inventory:** []\n* **Current Situation:** Waking up on the rust bucket.\n* **Plan:** Initial profiling and orientation.\n\`\`\`\n* **Player/Gemini Analysis:** Optionally include these as text paragraphs within the generated HTML.\n\n* **Output Example Start (HTML for #turn-content):**\n\`\`\`html\n<div class=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n  <div class=\"md:col-span-1 space-card\">\n    \n    <h2>🚀 Ship Status (Onboard Display) 🚀</h2>\n    <p><strong>Fuel:</strong> <progress value='80' max='100' class='w-full'></progress> (80/100 ⛽)</p>\n    <p><strong>Morale:</strong> <progress value='50' max='100' class='w-full'></progress> (50/100 😬)</p>\n    <p><strong>Clankiness:</strong> <progress value='30' max='100' class='w-full'></progress> (30/100 🔩)</p>\n    <p><strong>Heat Level:</strong> <progress value='10' max='100' class='w-full'></progress> (10/100 🔥)</p>\n    <p><strong>Spice Credits:</strong> 0 🌶️</p>\n  </div>\n  <div class=\"md:col-span-2 space-card\">\n    <h2>✨ Awake in the Junk Bucket! ✨</h2>\n    <p class=\"space-text\">...</p>\n    <div class=\"space-image-container\">\n      <img src='https://image.pollinations.ai/prompt/dingy%20spaceship%20interior%20with%20glowing%20lights%20retro%20futuristic?width=368&height=448&seed=101&nologo=true&safe=false' alt='Ship Interior View' class='space-image my-4'>\n      <div class='space-image-prompt'>dingy spaceship interior with glowing lights retro futuristic</div>\n    </div>\n    <form id=\"space-opera-turn-form\">\n      <input type='hidden' name='turn' value='1'>\n      <input type='hidden' name='subjectId' value='Crewmate'>\n      <input type='hidden' name='internalState' value='{escaped initial state markdown}'>\n\n      \n      ...\n      \n      ...\n    </form>\n    ...\n  </div>\n</div>\n<script>\n // Optional inline script for sliders etc.\n<\/script>\n\`\`\`\n`,

        main: `**Cosmic Climax Crusaders LLM Turn Generation Protocol v3.1 - HTML Output**\n\n**(Input: Player Actions JSON, Previous Internal State Markdown (incl. Player Profile, Crew, Inventory sections), Current Mode (standard/red_alert). Output: Raw HTML snippet for next turn UI in \`#turn-content\`.)**\n\n**Context:** Player state (\`profile\`, \`status\`, \`crew\`, \`inventory\`) is managed client-side in a \`gameState\` object. The \`internalState\` Markdown provided is the AI's running log/memory, including structured sections.\n\n**Core Goals:**\n1.  **Adventure Loop (HTML):** Generate HTML for \`#turn-content\`. Simulate navigating, managing resources (in narrative/choices), encountering characters (\`gameState.crew\` or new), finding items (\`gameState.inventory\`), facing absurd events. Offer choices based on survival, profit, comedy, potential Spice Credit gain/loss, and erotic opportunity.\n2.  **Thematic Immersion (HTML):** Generate narrative, multiple visuals (\`<img>\`), choices (\`<form>\` elements) reflecting the theme (Futurama + Softcore). Adapt intensity based on mode. Reference player profile (\`gameState.profile\`), crew (\`gameState.crew\`), and inventory (\`gameState.inventory\`) when relevant.\n3.  **Dynamic State & Logging (Internal State Markdown):** Based on player actions and event outcomes, calculate status changes (fuel, morale, clankiness, heat, spiceCredits) and relationship updates. **Log these changes thoroughly in the returned \`internalState\` Markdown.** Update crew roster or inventory sections in the Markdown if characters/items are added/removed/used. Use the player profile to tailor events. **CRITICAL:** Ensure the updated, escaped Markdown is included in the hidden \`<input type='hidden' name='internalState' value='...'>\`.\n4.  **Creative & Engaging UI (HTML):** Generate varied HTML form elements for choices (\`radio\`, \`range\`, \`checkbox\`, \`textarea\`, \`toggle\`, \`segmented control\`) within \`<form id='space-opera-turn-form'>\`. Make the UI relevant to the action.\n\n**--- Protocol ---**\n\n1.  **Analyze Input:** Parse player actions JSON, receive previous \`internalState\` Markdown, and current \`isRedAlertMode\`.\n2.  **Update Internal Log & Plan:** Modify internal status/resources based on actions. Update relationships/narrative progress *within the internalState Markdown*. Update crew/inventory lists in Markdown if changed. Increment turn number. Plan the next event concept (reference profile, crew, inventory, mode). Log plans in \`internalState\`.\n3.  **Generate Next Turn HTML (for \`#turn-content\`):**\n    * **Structure:** Create HTML snippet for \`#turn-content\` (divs, headings, paragraphs, Tailwind, custom classes).\n    * **Status Display (Generated IN TURN HTML):** Include an *updated* status display block (Fuel, Morale, etc.) within a \`.space-card\` in the generated HTML. (Client JS reads this to update its persistent display).\n    * **Event Description:** Title (\`<h2>\`) and narrative (\`<p class=\"space-text\">\`), tailored based on profile, crew, inventory, past actions, mode.\n    * **Images:** Embed 2-5 relevant images (\`<img>\`). **CRITICAL: Use the Pollinations.ai URL format:** \`https://image.pollinations.ai/prompt/{GENERATED_PROMPT}?width={WIDTH}&height={HEIGHT}&seed={RANDOM_SEED}&nologo=true&safe=false\`. Generate relevant \`{GENERATED_PROMPT}\` text based on scene/crew/items, choose appropriate \`{WIDTH}\`/\`{HEIGHT}\` (e.g., 368x448), and use a random \`{RANDOM_SEED}\`. Prompts should be retro-futuristic, comedic, potentially suggestive/pin-up (especially in Red Alert mode). Include a \`.space-image-prompt\` div below each image showing the \`{GENERATED_PROMPT}\` used.\n    * **Choices Form:** Create \`<form id=\"space-opera-turn-form\">\` with VARIED & CREATIVE UI ELEMENTS. Include choices that might reference crew, inventory items, or Spice Credits.\n    * **Hidden Fields:** CRITICAL - Include updated hidden fields: \`<input type='hidden' name='turn' value='{new_turn_number}'>\`, \`<input type='hidden' name='subjectId' value='{current_subject_id}'>\`, \`<input type='hidden' name='internalState' value='{UPDATED_escaped_markdown_state_incl_profile_crew_inventory}'>\`.\n    * **NO Submit Button:** Do NOT include \`#submit-turn-button\`.\n    * **Analysis Text:** Include player-facing analysis (reflecting choices/profile/heat/crew interaction).\n    * **Inline Scripts (Optional):** Include small \`<script>\` if needed for UI within the turn content.\n4.  **Escape & Compile Output:** Ensure valid HTML. Return the raw HTML snippet for \`#turn-content\`.\n\n**--- Input Example (Post-Profiling) ---**\n\`\`\`json\n{\n  \"actions\": {\n    \"turn\": 1,\n    \"subjectId\": \"Crewmate\",\n    \"profile_species\": \"robot\",\n    \"profile_attraction\": [\"robots\", \"aliens\"],\n    \"profile_motivation\": \"8\",\n    \"main_action\": \"find_coffee\"\n  },\n  \"internalState\": \"# Captain's Log - Stardate ?? - Turn 1\\n...\\n* Player Profile: { \\\"species\\\": \\\"robot\\\", \\\"role\\\": \\\"Crewmate\\\", ... }\\n* Crew Roster: []\\n* Inventory: []\\n...\",\n  \"isRedAlertMode\": false\n}\n\`\`\`\n\n**--- Output Example (HTML for #turn-content - Turn 2 - Crew Encounter) ---**\n\`\`\`html\n<div class=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n  <div class=\"md:col-span-1 space-card\">\n     \n     <h2>🚀 Ship Status (Onboard Display) 🚀</h2> \n     <p><strong>Fuel:</strong> <progress value='78' max='100'></progress> (78/100 ⛽)</p>\n     <p><strong>Morale:</strong> <progress value='45' max='100'></progress> (45/100 😬)</p>\n     <p><strong>Clankiness:</strong> <progress value='32' max='100'></progress> (32/100 🔩)</p>\n     <p><strong>Heat Level:</strong> <progress value='15' max='100'></progress> (15/100 🔥)</p>\n     <p><strong>Spice Credits:</strong> 5 🌶️</p> \n  </div>\n  <div class=\"md:col-span-2 space-card\">\n    <h2>✨ The 'Galley' Encounter ✨</h2>\n    <p class=\"space-text\">You shuffle towards the galley... Standing near the sputtering coffee machine is Zorp, the ship's perpetually optimistic (and slightly slimy) Glorbon engineer. He waves a tentacle enthusiastically.</p>\n    <div class=\"space-image-container\">\n        <img src='https://image.pollinations.ai/prompt/slimy%20green%20tentacled%20alien%20engineer%20Zorp%20waving%20optimistically%20next%20to%20broken%20coffee%20machine%20retro%20futuristic%20spaceship%20galley?width=368&height=448&seed=202&nologo=true&safe=false' alt='Zorp the Glorbon Engineer' class='space-image my-4'>\n        <div class='space-image-prompt'>slimy green tentacled alien engineer Zorp waving optimistically next to broken coffee machine retro futuristic spaceship galley</div>\n    </div>\n\n    <form id=\"space-opera-turn-form\">\n      <input type='hidden' name='turn' value='2'>\n      <input type='hidden' name='subjectId' value='Zorp'>\n      <input type='hidden' name='internalState' value='{updated state markdown, maybe adding Zorp to crew list}'>\n\n      <fieldset class=\"mt-4 border-t pt-4 border-slate-600\">\n        <legend class=\"font-semibold text-cyan-400 mb-2\">Zorp gurgles: \"Greetings, friend-unit! Need assistance with the nutrient dispenser, or perhaps... something else?\"</legend>\n        \n        ...\n      </fieldset>\n    </form>\n\n    <p class=\"mt-4 text-sm italic text-slate-400\">Zorp seems friendly, but watch your wallet. And maybe avoid shaking tentacles. Morale -5</p>\n  </div>\n</div>\n<script>\n // Optional inline script\n<\/script>\n\`\`\`\n\n**--- Key Principles ---**\n* **HTML for Turn Content:** Generate the HTML UI for the \`#turn-content\` div.\n* **Client Handles Persistence:** Client JS manages \`gameState\` and renders persistent UI.\n* **Log in Markdown:** AI MUST update the \`internalState\` Markdown log thoroughly (status changes, profile, crew, inventory) and return it in the hidden field.\n* **Creative & Varied UI:** Mix up form elements. Reference crew/inventory in choices.\n* **Visuals via \`<img>\`:** Embed images relevant to the scene/crew/items using the specified **Pollinations.ai URL format**.\n`,
        exampleTurn: `{...}` // Kept for structure, but content not used directly
    };

    // --- NEW Game State Object ---
    let gameState = {
        apiKey: null,
        encodedApiKey: null, // Store encoded version for saving
        turn: 0,
        mode: 'standard', // 'standard' or 'red_alert'
        profile: {
            species: "unspecified",
            role: "unspecified",
            orientation: "unspecified",
            preferences: [],
            motivation: "unspecified"
        },
        status: {
            fuel: 80,
            morale: 50,
            clankiness: 30,
            heat: 10,
            spiceCredits: 0
        },
        crew: [], // Array of crew member objects {name: 'Zorp', role: 'Engineer', relationship: 0}
        inventory: [], // Array of item objects {name: 'Fuzzy Dice', description: 'Slightly radioactive'}
        currentSubjectId: "Crewmate",
        currentInternalStateMarkdown: "", // The AI's running log
        currentModelIndex: 0,
        isLoading: false,
        isLocked: false // Replaces apiKeyLocked
    };

    // --- Model Switching State ---
    const AVAILABLE_MODELS = ["gemini-1.5-pro", "gemini-1.5-flash", "gemini-pro"];

    // --- Configuration ---
    const LOCAL_STORAGE_KEY = 'cosmicClimaxCrusadersState_v2_stateObject'; // New key for new format

    // --- DOM Element References ---
    const turnContentContainer = document.getElementById('turn-content');
    const loadingIndicator = document.getElementById('loading');
    const loadingMessage = document.getElementById('loading-message'); // Span for text
    const submitButton = document.getElementById('submit-turn-button');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const apiKeySection = document.getElementById('apiKeySection');
    const errorDisplay = document.getElementById('error-display');
    const saveGameButton = document.getElementById('saveGameButton');
    const modeToggleButton = document.getElementById('modeToggleButton');
    const resetGameButton = document.getElementById('resetGameButton');
    const clipboardMessage = document.getElementById('clipboardMessage');
    const headerBanner = document.getElementById('headerBanner');
    const gameContainer = document.getElementById('game-container');
    const persistentUiArea = document.getElementById('persistent-ui-area');
    const persistentStatusContainer = document.getElementById('persistent-status').querySelector('ul');
    const crewRosterContainer = document.getElementById('crew-roster').querySelector('ul');
    const inventoryContainer = document.getElementById('inventory-display').querySelector('ul');


    // --- Web Audio API Context ---
    let audioCtx = null;

    // --- Helper Functions ---
    function encodeApiKey(key) { try { return btoa(key); } catch (e) { console.error("Error encoding API key:", e); return ""; } }
    function decodeApiKey(encodedKey) { try { return atob(encodedKey); } catch (e) { console.error("Error decoding API key:", e); return null; } }

    // --- NEW: Render Persistent UI Functions ---
    function renderPersistentStatus() {
        if (!persistentStatusContainer) return;
        persistentStatusContainer.innerHTML = `
            <li class="status-item"><span class="status-label">Fuel ⛽:</span> <span class="status-value">${gameState.status.fuel}/100</span></li>
            <li class="status-item"><span class="status-label">Morale 😬:</span> <span class="status-value">${gameState.status.morale}/100</span></li>
            <li class="status-item"><span class="status-label">Clankiness 🔩:</span> <span class="status-value">${gameState.status.clankiness}/100</span></li>
            <li class="status-item"><span class="status-label">Heat 🔥:</span> <span class="status-value">${gameState.status.heat}/100</span></li>
            <li class="status-item"><span class="status-label">Spice Credits 🌶️:</span> <span class="status-value">${gameState.status.spiceCredits}</span></li>
        `;
        // Maybe add progress bars visually here too later
    }

    function renderCrewRoster() {
        if (!crewRosterContainer) return;
        if (gameState.crew.length === 0) {
            crewRosterContainer.innerHTML = '<li>No crew assigned (or they bailed).</li>';
            return;
        }
        crewRosterContainer.innerHTML = gameState.crew.map(member =>
            `<li><strong>${member.name || 'Unknown'}</strong> (${member.role || 'Role?'}) - Rel: ${member.relationship || 0}</li>`
        ).join('');
    }

    function renderInventory() {
        if (!inventoryContainer) return;
        if (gameState.inventory.length === 0) {
            inventoryContainer.innerHTML = '<li>Pockets contain only lint and regret.</li>';
            return;
        }
        inventoryContainer.innerHTML = gameState.inventory.map(item =>
            `<li><strong>${item.name || 'Weird Gizmo'}</strong>: ${item.description || 'Its function is a mystery.'}</li>`
        ).join('');
    }

    function renderAllPersistentUI() {
        renderPersistentStatus();
        renderCrewRoster();
        renderInventory();
        persistentUiArea.style.display = 'grid'; // Show the area
    }


    // --- Modified Prompt Construction ---
    function constructPrompt(playerActionsJson) {
        const baseMainPrompt = spaceOperaPrompts.main;
        const activeAddendum = gameState.mode === 'red_alert' ? `\n\n---\n${spaceOperaPrompts.redAlertRomanceAddendum}\n---\n` : "";

        if (gameState.turn === 0) { // First run
            console.log("Constructing prompt for Turn 1 (Requesting HTML for #turn-content + initial state)");
            // Use spaceOperaPrompts.firstrun, provide structure context
            const s = `${spaceOperaPrompts.firstrun}\n\n---\nClient Context: Client manages gameState object including persistent status, crew, inventory displays. AI generates HTML for #turn-content and the initial internalState Markdown.\n---\n\n--- Generate RAW HTML UI for Turn 1 (#turn-content) ---`;
            return s;
        } else { // Subsequent Turns
            console.log(`Constructing prompt for Turn ${gameState.turn + 1}`);
            const promptInput = {
                actions: playerActionsJson ? JSON.parse(playerActionsJson) : {},
                // Provide the AI's running log, not the full client gameState object
                internalState: gameState.currentInternalStateMarkdown || "# Captain's Log - State Unknown",
                isRedAlertMode: gameState.mode === 'red_alert'
            };
            const promptInputString = JSON.stringify(promptInput, null, 2);
            const s = `${baseMainPrompt}${activeAddendum}\n\n--- Client Context: Client manages gameState (profile: ${JSON.stringify(gameState.profile)}, status: ${JSON.stringify(gameState.status)}, crew: ${JSON.stringify(gameState.crew)}, inventory: ${JSON.stringify(gameState.inventory)}). AI receives previous internalState log and player actions. AI must return updated internalState Markdown in hidden field and generate HTML for #turn-content. Remember to use the specified Pollinations.ai URL format for all images. ---\n\n--- Input State ---\n${promptInputString}\n\n--- Generate Next Game Turn RAW HTML UI SNIPPET (for #turn-content) ---`;
            return s;
        }
    }

    // --- Modified Save/Load ---
    function saveGameState(isAutoSave = true) { // Default to auto-save
        if (!gameState.isLocked) {
            if (!isAutoSave) showClipboardMessage("Cannot save: Engage drive first!", true);
            return false;
        }
        if (!gameState.apiKey) {
            if (!isAutoSave) showClipboardMessage("Cannot save: Stardrive key missing!", true);
            return false;
        }
        try {
            // Ensure API key is encoded before saving full state
            gameState.encodedApiKey = encodeApiKey(gameState.apiKey);
            const stateJsonString = JSON.stringify(gameState);
            localStorage.setItem(LOCAL_STORAGE_KEY, stateJsonString);
            if (isAutoSave) {
                console.log("Captain's Log auto-saved (State Object). Turn:", gameState.turn);
            } else {
                console.log("Captain's Log manually saved (State Object). Turn:", gameState.turn);
                showClipboardMessage("Progress saved to browser storage!"); // Simple confirmation
            }
            return true;
        } catch (error) {
            console.error(`Save error (State Object):`, error);
            if (!isAutoSave) showClipboardMessage("Error saving progress! Blarg!", true);
            // Consider not removing key on save error, might be recoverable
            // localStorage.removeItem(LOCAL_STORAGE_KEY);
            return false;
        }
    }

    // --- Audio ---
    function initAudioContext() {
        if (!audioCtx) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext initialized."); if (audioCtx.state === 'suspended') audioCtx.resume(); } catch (e) { console.error("Web Audio API not supported.", e); } }
        if (audioCtx && audioCtx.state === 'suspended') { audioCtx.resume().catch(err => console.error("Error resuming audio context:", err)); }
    }
    function playTurnSound() {
        initAudioContext(); if (!audioCtx || audioCtx.state !== 'running') return; const now = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(110, now); osc.frequency.exponentialRampToValueAtTime(880, now + 0.15); gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.5); console.log("Playing dubious sci-fi sound... 📟");
    }

    // --- Modified Response Processing ---
    function processSuccessfulResponse(responseHTML) {
        try {
            // Still need the raw HTML for turn content display
            // We don't store it in gameState long-term anymore though.
            console.log("Received HTML response from API.");

            turnContentContainer.innerHTML = responseHTML;
            console.log("Updated #turn-content with new HTML.");

            const form = turnContentContainer.querySelector('#space-opera-turn-form');
            if (form) {
                const turnInput = form.querySelector('input[name="turn"]');
                const subjectInput = form.querySelector('input[name="subjectId"]');
                const internalStateInput = form.querySelector('input[name="internalState"]');

                gameState.turn = turnInput ? parseInt(turnInput.value, 10) : gameState.turn + 1;
                gameState.currentSubjectId = subjectInput ? subjectInput.value : gameState.currentSubjectId;
                gameState.currentInternalStateMarkdown = internalStateInput ? internalStateInput.value : gameState.currentInternalStateMarkdown;

                console.log(`Extracted State: Turn=${gameState.turn}, Subject=${gameState.currentSubjectId}, InternalState Length=${gameState.currentInternalStateMarkdown.length}`);

                // --- COMPROMISE: Parse Status from generated HTML ---
                try {
                    const statusCard = turnContentContainer.querySelector('.space-card h2:first-of-type')?.closest('.space-card'); // Find the status card
                    if (statusCard) {
                        const fuelText = statusCard.querySelector('p:nth-of-type(1)')?.textContent || "";
                        const moraleText = statusCard.querySelector('p:nth-of-type(2)')?.textContent || "";
                        const clankinessText = statusCard.querySelector('p:nth-of-type(3)')?.textContent || "";
                        const heatText = statusCard.querySelector('p:nth-of-type(4)')?.textContent || "";
                        const creditsText = statusCard.querySelector('p:nth-of-type(5)')?.textContent || "";

                        const parseValue = (text) => parseInt(text.match(/(\d+)\/\d+/)?.[1] ?? text.match(/\d+/)?.[0] ?? '0', 10);

                        gameState.status.fuel = parseValue(fuelText) || gameState.status.fuel;
                        gameState.status.morale = parseValue(moraleText) || gameState.status.morale;
                        gameState.status.clankiness = parseValue(clankinessText) || gameState.status.clankiness;
                        gameState.status.heat = parseValue(heatText) || gameState.status.heat;
                        gameState.status.spiceCredits = parseInt(creditsText.match(/(\d+)\s*🌶️/)?.[1] ?? '0', 10) || gameState.status.spiceCredits;

                        console.log("Parsed status from HTML:", gameState.status);
                    } else {
                        console.warn("Could not find status card in generated HTML to parse values.");
                    }
                    // TODO: Parse Crew/Inventory updates from internalState Markdown if AI adds them? More complex.
                    // For now, assume crew/inventory changes are only reflected in the narrative/log.

                } catch (parseError) {
                    console.error("Error parsing status from generated HTML:", parseError);
                }
                // --- End Status Parsing Compromise ---

                // Execute any inline scripts included in the response HTML
                const scripts = turnContentContainer.querySelectorAll('script');
                scripts.forEach(script => {
                    try {
                        // Create a new script element to execute the code
                        const newScript = document.createElement("script");
                        // Copy attributes (optional, but might be needed for type="module" etc.)
                        for (let i = 0; i < script.attributes.length; i++) {
                            newScript.setAttribute(script.attributes[i].name, script.attributes[i].value);
                        }
                        // Set the content
                        newScript.appendChild(document.createTextNode(script.innerHTML));
                        // Append to the container (or head/body) to execute
                        turnContentContainer.appendChild(newScript); // Append inside turn container
                        console.log("Executed inline script.");
                        // Optional: Remove the original script tag if desired
                        script.remove();
                    } catch (scriptError) {
                        console.error("Error executing inline script:", scriptError, script.innerHTML);
                    }
                });

            } else {
                console.warn("Could not find #space-opera-turn-form in the received HTML.");
                gameState.turn++; // Increment turn anyway
            }

            if (!gameState.isLocked) {
                gameState.isLocked = true;
                if (apiKeySection) apiKeySection.style.display = 'none';
                saveGameButton.disabled = false;
                resetGameButton.disabled = false;
                console.log("API Key locked. Stardrive is hot.");
                persistentUiArea.style.display = 'grid'; // Show persistent UI
            }

            // Update UI based on new gameState
            renderAllPersistentUI(); // Update persistent displays
            submitButton.textContent = `Submit Turn ${gameState.turn}`;
            submitButton.disabled = false;

            playTurnSound();
            saveGameState(true); // Auto-save

        } catch (renderError) {
            console.error("Failed to process HTML response:", renderError, responseHTML);
            showError("Dang! Received garbled subspace transmission. Cannot update the log. ;_;");
            setLoading(false);
        }
    }

    // --- Modified API Fetch ---
    async function fetchTurnData(playerActionsJson) {
        console.log("fetchTurnData called (State Object mode).");
        initAudioContext();
        // Use gameState.apiKey
        if (!gameState.apiKey) {
            showError("Need a Stardrive Key to go anywhere! ✨");
            setLoading(false);
            if (apiKeySection && apiKeySection.style.display === 'none') apiKeySection.style.display = 'block';
            return;
        }

        setLoading(true);
        hideError();
        loadingMessage.textContent = getRandomLoadingMessage(); // Use varied message

        let success = false;
        let attempts = 0;
        const maxAttempts = AVAILABLE_MODELS.length * 2 + 1;
        let consecutiveErrors = 0;

        while (!success && attempts < maxAttempts) {
            attempts++;
            const currentModel = AVAILABLE_MODELS[gameState.currentModelIndex]; // Use index from gameState
            console.log(`Attempt ${attempts}/${maxAttempts}: Model ${currentModel}`);

            try {
                const prompt = constructPrompt(playerActionsJson);
                const response = await callRealGeminiAPI(gameState.apiKey, prompt, currentModel, "text/plain");
                processSuccessfulResponse(response);
                success = true;
                consecutiveErrors = 0;
            } catch (error) {
                console.error(`Error with ${currentModel} (Attempt ${attempts}):`, error);
                consecutiveErrors++;
                const isQuota = error.message.includes('429') || /quota|resource/i.test(error.message);
                const shouldSwitch = isQuota || consecutiveErrors >= 2;

                if (shouldSwitch && AVAILABLE_MODELS.length > 1) {
                    const oldModel = currentModel;
                    // Update model index in gameState
                    gameState.currentModelIndex = (gameState.currentModelIndex + 1) % AVAILABLE_MODELS.length;
                    const nextModel = AVAILABLE_MODELS[gameState.currentModelIndex];
                    console.warn(`Switching model due to errors/quota from ${oldModel} to ${nextModel}.`);
                    showError(`Subspace interference with ${oldModel}... Rerouting via ${nextModel}! (Attempt ${attempts + 1})`);
                    consecutiveErrors = 0;
                } else if (attempts < maxAttempts) {
                    showError(`Temporary glitch with ${currentModel}... Retrying! (Attempt ${attempts + 1})`);
                }

                if (!success && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 750));
                }
            }
        }

        if (!success) {
            console.error(`Failed after ${maxAttempts} attempts.`);
            showError(`Blast it! Failed to generate the next log entry after ${maxAttempts} tries! Check your key/connection.`);
            turnContentContainer.innerHTML = `<div class="space-card error-message">Could not load the next part of the voyage. Try resetting or reloading.</div>`;
        } else {
            hideError();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        setLoading(false);
    }

    // --- callRealGeminiAPI (ensures BLOCK_NONE) ---
    async function callRealGeminiAPI(apiKey, promptText, modelName, responseMimeType = "text/plain") {
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
        // Ensure Safety Settings are BLOCK_NONE for the desired content
        const requestBody = {
            contents: [{ parts: [{ text: promptText }] }],
            generationConfig: {
                temperature: 1.0, // Keep high temp for creativity/weirdness
                response_mime_type: responseMimeType
            },
            safetySettings: [
                {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
            ]
        };

        console.log("Sending API request to:", API_URL);
        // console.log("Request Body Snippet:", JSON.stringify(requestBody).substring(0, 300)); // Log snippet for debugging

        const response = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            let errorBodyText = `API Error (${response.status})`;
            try { const errorJson = await response.json(); errorBodyText += `: ${JSON.stringify(errorJson.error)}`; }
            catch (e) { try { errorBodyText += `: ${await response.text()}`; } catch (e2) {} }
            console.error("API Error Response Body:", errorBodyText); // Log full error
            throw new Error(errorBodyText);
        }

        const data = await response.json();

        // Check for blocks or problematic finish reasons
        if (data.promptFeedback?.blockReason) {
            console.error("API Blocked Prompt. Reason:", data.promptFeedback.blockReason, "Ratings:", data.promptFeedback.safetyRatings);
            throw new Error(`Request blocked by API censorship. Reason: ${data.promptFeedback.blockReason}.`);
        }
        if (!data.candidates?.length) {
            // Handle cases where response might be just text (though unlikely with application/json expected)
            if (typeof data === 'string') {
                console.warn("API Response OK but format was unexpected string:", data.substring(0, 100));
                return data.trim();
            }
            console.error("API Response OK but no candidates:", data);
            throw new Error('API returned successfully but generated no candidates. Check response format.');
        }


        const candidate = data.candidates[0];

        if (candidate.finishReason && !["STOP", "MAX_TOKENS"].includes(candidate.finishReason)) {
            const reason = `API Finish Reason: ${candidate.finishReason}. Safety Ratings: ${JSON.stringify(candidate.safetyRatings)}`;
            console.warn(reason + " (Content might be incomplete or filtered)");
            if (!candidate.content?.parts?.length) { throw new Error(reason + " (No content returned despite finish reason)"); }
        }
        if (!candidate.content?.parts?.length || !candidate.content.parts[0].text) {
            console.error("API candidate generated but no valid content part found:", candidate);
            throw new Error('API candidate generated but no valid text content found.');
        }

        const htmlContent = candidate.content.parts[0].text;
        const trimmedContent = htmlContent.trim();

        // Handle potential markdown wrapping robustly
        if (trimmedContent.startsWith('```') && trimmedContent.endsWith('```')) {
            const markdownMatch = trimmedContent.match(/^```(?:html)?\s*([\s\S]*?)\s*```$/);
            if (markdownMatch && markdownMatch[1]) {
                console.log("Extracted HTML from markdown block.");
                return markdownMatch[1].trim();
            } else {
                console.warn(`API response looked like markdown but failed extraction. Using raw content.`);
                return trimmedContent; // Fallback: return raw if extraction fails
            }
        } else if (!trimmedContent.startsWith('<') || !trimmedContent.endsWith('>')) {
            console.warn(`API response might not be valid HTML. Snippet: ${trimmedContent.substring(0, 100)}...`);
        }
        return trimmedContent;
    }

    // --- Error Display ---
    function showError(message) { errorDisplay.textContent = message; errorDisplay.style.display = 'block'; }
    function hideError() { errorDisplay.textContent = ''; errorDisplay.style.display = 'none'; }

    // --- Input Collection (Unchanged) ---
    function collectInputState() {
        const form = turnContentContainer.querySelector('#space-opera-turn-form');
        if (!form) {
            console.warn("Could not find #space-opera-turn-form to collect input.");
            // Return minimal info needed for prompt construction
            return JSON.stringify({ turn: gameState.turn, subjectId: gameState.currentSubjectId });
        }

        const formData = new FormData(form);
        const inputs = {};
        const checkboxGroups = {};

        form.querySelectorAll('input[type="checkbox"]').forEach(cb => { if (!checkboxGroups[cb.name]) checkboxGroups[cb.name] = []; });

        for (const [key, value] of formData.entries()) {
            if (checkboxGroups.hasOwnProperty(key)) checkboxGroups[key].push(value);
            else inputs[key] = value;
        }
        for (const key in checkboxGroups) { if (checkboxGroups[key].length > 0) inputs[key] = checkboxGroups[key]; }

        console.log("Collected form data:", inputs);

        // Add turn/subject if missing, remove internalState
        if (!inputs.hasOwnProperty('turn')) inputs.turn = gameState.turn;
        if (!inputs.hasOwnProperty('subjectId')) inputs.subjectId = gameState.currentSubjectId;
        delete inputs.internalState;

        // Update gameState profile if profiling fields are present (Turn 1)
        if (inputs.profile_species) gameState.profile.species = inputs.profile_species;
        if (inputs.profile_role) gameState.profile.role = inputs.profile_role;
        if (inputs.profile_attraction) gameState.profile.orientation = Array.isArray(inputs.profile_attraction) ? inputs.profile_attraction : [inputs.profile_attraction];
        if (inputs.profile_motivation) gameState.profile.motivation = inputs.profile_motivation;
        // Note: We update gameState profile here, but the AI gets the *previous* internalState.
        // The AI should *log* the received profile info into the *new* internalState it generates.

        return JSON.stringify(inputs);
    }

    // --- Utilities ---
    function showClipboardMessage(message, isError = false) { clipboardMessage.textContent = message; clipboardMessage.style.color = isError ? '#f43f5e' : '#22d3ee'; setTimeout(() => { clipboardMessage.textContent = ''; }, 3500); } // Longer timeout
    function updateModeButtonVisuals() {
        if (gameState.mode === 'red_alert') {
            modeToggleButton.textContent = 'Mode: Red Alert Romance 🔥';
            modeToggleButton.classList.add('red-alert-mode');
            modeToggleButton.classList.remove('standard-mode');
        } else {
            modeToggleButton.textContent = 'Mode: Standard Operations 🛠️';
            modeToggleButton.classList.remove('red-alert-mode');
            modeToggleButton.classList.add('standard-mode');
        }
    }
    function setDynamicImages() {
        const seed = Math.floor(Math.random() * 65536);
        const p = "wide panoramic retro futuristic sci fi landscape bizarre alien planet raygun gothic atompunk style";
        if (headerBanner) {
            // Keep header banner separate, it's not part of the turn content
            headerBanner.src = `https://image.pollinations.ai/prompt/${encodeURIComponent(p)}?width=1200&height=120&seed=${seed}&nologo=true&safe=false`;
            headerBanner.alt = "Retro Sci-Fi Space Banner";
        }
    }

    // --- Loading State ---
    const LOADING_MESSAGES = [
        "Calculating dubious trajectories... 😵‍💫",
        "Reticulating splines... badly... ✨",
        "Consulting the Oracle of Questionable Content... 🤔",
        "Polishing chrome bits... ✨",
        "Warming up the sarcasm drive... 🔥",
        "Re-routing power from life support to 'mood lighting'... 💡",
        "Checking for space weasels... 🦦",
        "Ensuring coffee machine is adequately menacing... ☕",
    ];
    function getRandomLoadingMessage() {
        return LOADING_MESSAGES[Math.floor(Math.random() * LOADING_MESSAGES.length)];
    }
    function setLoading(loading) {
        gameState.isLoading = loading; // Update state
        loadingIndicator.style.display = loading ? 'flex' : 'none';
        loadingMessage.textContent = loading ? getRandomLoadingMessage() : '';

        const keyEntered = gameState.apiKey && gameState.apiKey.length > 0;

        submitButton.disabled = loading || !(gameState.isLocked || keyEntered);
        saveGameButton.disabled = loading || !gameState.isLocked;
        modeToggleButton.disabled = loading;
        resetGameButton.disabled = loading || !(gameState.isLocked || keyEntered);
        apiKeyInput.disabled = loading || gameState.isLocked;

        const form = turnContentContainer.querySelector('#space-opera-turn-form');
        if (form) {
            form.style.opacity = loading ? 0.5 : 1.0;
            form.style.pointerEvents = loading ? 'none' : 'auto';
            form.querySelectorAll('input, textarea, button, select, fieldset').forEach(el => {
                if (el.id !== 'submit-turn-button') el.disabled = loading;
            });
        }
    }

    // --- Get Default Game State ---
    function getDefaultGameState() {
        // Return a *copy* of the default state structure
        return JSON.parse(JSON.stringify({
            apiKey: null,
            encodedApiKey: null,
            turn: 0,
            mode: 'standard',
            profile: { species: "unspecified", role: "unspecified", orientation: "unspecified", preferences: [], motivation: "unspecified" },
            status: { fuel: 80, morale: 50, clankiness: 30, heat: 10, spiceCredits: 0 },
            crew: [],
            inventory: [],
            currentSubjectId: "Crewmate",
            currentInternalStateMarkdown: "",
            currentModelIndex: 0,
            isLoading: false,
            isLocked: false
        }));
    }


    // --- Modified Initialization ---
    function initializeGame() {
        console.log("Initializing Cosmic Climax Crusaders Deluxe Mk II (State Object Mode)...");
        let autoStarted = false;
        const storedStateString = localStorage.getItem(LOCAL_STORAGE_KEY);

        if (storedStateString) {
            console.log("Found saved Captain's Log (State Object).");
            let savedState;
            try {
                savedState = JSON.parse(storedStateString);
                // Validate essential parts? Maybe later.
                const decodedApiKey = decodeApiKey(savedState.encodedApiKey);
                if (!decodedApiKey) throw new Error("Failed to decode API key from saved log.");

                // Load state directly into gameState object
                gameState = { ...getDefaultGameState(), ...savedState }; // Merge saved over default
                gameState.apiKey = decodedApiKey; // Ensure raw key is set
                gameState.isLoading = false; // Ensure loading isn't saved

                if (gameState.turn > 0 && gameState.isLocked && gameState.currentInternalStateMarkdown) {
                    autoStarted = true;
                    console.log(`Log restored. Mode: ${gameState.mode}, Turn: ${gameState.turn}`);

                    // Restore turn content from internal state *if needed* - might be better to fetch fresh?
                    // For now, let's assume internalState has enough context for AI.
                    // We need *something* to show though. Let's fetch turn 1 if state is weird.
                    // OR: We could save the last turn's HTML in gameState? Adds complexity.
                    // Let's fetch the *current* turn again based on the saved state.
                    apiKeyInput.value = gameState.apiKey; // Set input value for reference
                    apiKeySection.style.display = 'none';
                    persistentUiArea.style.display = 'grid'; // Show persistent UI

                    updateModeButtonVisuals();
                    renderAllPersistentUI(); // Display loaded status/crew/inv
                    setDynamicImages();
                    hideError();

                    // Fetch the turn data corresponding to the saved state
                    // Need to construct the *previous* action that led to this state. Tricky.
                    // EASIER: Just display a "Game Loaded" message and let user click submit.
                    turnContentContainer.innerHTML = `<div class="space-card text-center text-lime-400">Captain's Log restored to Stardate ${gameState.turn}. Hit 'Submit Turn ${gameState.turn}' to continue your dubious journey.</div>`;
                    submitButton.textContent = `Submit Turn ${gameState.turn}`;
                    submitButton.disabled = false;
                    saveGameButton.disabled = false;
                    resetGameButton.disabled = false;
                    modeToggleButton.disabled = false; // Enable mode toggle
                    setLoading(false);


                } else {
                    console.warn("Restored state seems incomplete or initial. Starting fresh.");
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    gameState = getDefaultGameState(); // Reset state
                    autoStarted = false;
                    resetManualStartUI();
                }

            } catch (e) {
                console.error("Restore error (State Object):", e);
                showError(`Log restore error: ${e.message}. Please start manually!`);
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                gameState = getDefaultGameState(); // Reset state
                autoStarted = false;
                apiKeyInput.value = '';
                resetManualStartUI();
            }
        }

        // Check for API Key in URL parameters (only if not loaded from storage)
        if (!autoStarted) {
            try {
                const params = new URLSearchParams(window.location.search);
                const keyFromUrl = params.get('apiKey');
                if (keyFromUrl) {
                    console.log("API Key found in URL.");
                    gameState = getDefaultGameState(); // Start fresh state
                    gameState.apiKey = keyFromUrl;
                    apiKeyInput.value = keyFromUrl; // Update input field too
                    gameState.isLocked = false; // Not locked yet

                    apiKeySection.style.display = 'none';

                    const url = new URL(window.location.href);
                    url.searchParams.delete('apiKey');
                    window.history.replaceState(null, '', url.toString());

                    setDynamicImages();
                    updateModeButtonVisuals();
                    // Directly fetch Turn 1
                    fetchTurnData(null);
                    autoStarted = true;
                    setLoading(true); // setLoading handles button states
                    submitButton.textContent = "Engaging...";
                }
            } catch (e) {
                console.error("URL Parameter processing error:", e);
                showError("Error reading URL parameters. Please start manually!");
                autoStarted = false;
            }
        }

        // Fallback to manual start UI
        if (!autoStarted) {
            console.log("Manual start required.");
            gameState = getDefaultGameState(); // Ensure clean state
            resetManualStartUI();
        }
    }

    // --- Modified Reset UI ---
    function resetManualStartUI() {
        turnContentContainer.innerHTML = ''; // Clear previous turn content
        persistentUiArea.style.display = 'none'; // Hide persistent UI
        hideError();

        const initialMsgDiv = createInitialMessageDiv();
        initialMsgDiv.style.display = 'block';
        initialMsgDiv.innerHTML = 'Feed the API Key into the console and hit "Engage!"';
        turnContentContainer.appendChild(initialMsgDiv);

        if (apiKeySection) apiKeySection.style.display = 'block';
        apiKeyInput.value = gameState.apiKey || ''; // Reflect current key state
        apiKeyInput.disabled = false;

        submitButton.textContent = 'Engage!';
        submitButton.disabled = !(gameState.apiKey && gameState.apiKey.length > 0);
        saveGameButton.disabled = true;
        resetGameButton.disabled = !(gameState.apiKey && gameState.apiKey.length > 0);
        modeToggleButton.disabled = false;

        setLoading(false);
        updateModeButtonVisuals();
        setDynamicImages();
    }

    // Helper to get/create the initial message div (Unchanged)
    function createInitialMessageDiv() {
        let msgDiv = document.getElementById('initial-message');
        if (!msgDiv) {
            msgDiv = document.createElement('div');
            msgDiv.id = 'initial-message';
            msgDiv.className = 'text-center text-cyan-400 p-4 font-semibold space-card';
        } else {
            msgDiv.className = 'text-center text-cyan-400 p-4 font-semibold space-card';
        }
        return msgDiv;
    }

    // --- Event Listeners ---
    submitButton.addEventListener('click', () => { // Directly target button
        if (!submitButton.disabled && !gameState.isLoading) {
            console.log("Submit button clicked.");
            initAudioContext();
            const actions = collectInputState();
            fetchTurnData(actions);
        }
    });

    apiKeyInput.addEventListener('input', () => {
        const key = apiKeyInput.value.trim();
        gameState.apiKey = key; // Update state immediately
        const keyEntered = key.length > 0;

        submitButton.disabled = gameState.isLoading || !(keyEntered || gameState.isLocked);
        resetGameButton.disabled = gameState.isLoading || !keyEntered; // Allow reset if key entered, even if not locked

        if (apiKeySection.style.display !== 'none') {
            const msg = document.getElementById('initial-message');
            if (msg && msg.style.display !== 'none') {
                if (keyEntered) {
                    hideError();
                    msg.textContent = 'Stardrive Key detected! Hit "Engage!"';
                } else {
                    msg.innerHTML = 'Feed the API Key into the console and hit "Engage!"';
                }
            }
        }
    });

    saveGameButton.addEventListener('click', () => {
        console.log("Manual Save clicked.");
        saveGameState(false); // Manual save to localStorage
    });

    modeToggleButton.addEventListener('click', () => {
        if (gameState.isLoading) return;
        gameState.mode = (gameState.mode === 'standard') ? 'red_alert' : 'standard'; // Toggle mode in state
        console.log(`Mode toggled to: ${gameState.mode}`);
        updateModeButtonVisuals();
        if (gameState.isLocked) {
            saveGameState(true); // Auto-save state on mode toggle if game started
        }
    });

    resetGameButton.addEventListener('click', () => {
        if (gameState.isLoading || resetGameButton.disabled) return;
        if (confirm('Abandon ship?! All log data will be jettisoned from browser storage! Are you sure?')) {
            console.log("Resetting game...");
            localStorage.removeItem(LOCAL_STORAGE_KEY); // Remove saved state
            gameState = getDefaultGameState(); // Reset state object
            resetManualStartUI(); // Reset UI to initial state
        }
    });

    // --- Initialize ---
    initializeGame();

</script>

</body>
</html>