<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kawaii Heart Adventures - HTML Deluxe</title> <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&family=Playfair+Display:wght@700&display=swap"
          rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.css">
    <style>
        /* Embedded styles adapted for Kawaii/Loving/Erotic theme + Multi-Image */
        /* NOTE: Many specific element styles (.geems-*, #status-display .status-item, etc.)
           might become less relevant if the LLM generates its own styled HTML structure.
           Keeping them for now as a fallback or if the LLM uses these classes. */
        body {
            font-family: 'Nunito', sans-serif; /* Cuter font */
            background: linear-gradient(135deg, #ffdde1 0%, #ee9ca7 100%); /* Pink gradient background */
            color: #583c5a; /* Dark pink/purple text */
            margin: 0;
            padding: 0;
        }

        /* Header Styling */
        .site-header { padding: 0; margin-bottom: 1rem; text-align: center; position: relative; overflow: hidden; }
        .header-banner-image { width: 100%; height: 120px; object-fit: cover; display: block; opacity: 0.8; }
        .site-header h1 { font-family: 'Playfair Display', serif; font-size: 2.8rem; color: #ffffff; text-shadow: 1px 1px 5px rgba(224, 82, 99, 0.8); margin: 0; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; padding: 0 1rem; box-sizing: border-box; background: rgba(255, 105, 180, 0.5); padding-top: 0.4rem; padding-bottom: 0.4rem; }

        /* Footer Styling */
        .site-footer { margin-top: 2rem; padding: 1.5rem 1rem; text-align: center; font-size: 0.875rem; color: #8c5f8f; border-top: 1px solid #f4acb7; background-color: rgba(255, 255, 255, 0.3); }
        .footer-buttons { display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; margin-bottom: 1rem; }
        #clipboardMessage { font-size: 0.8rem; color: #e11d48; height: 1.2em; font-weight: 600; margin-bottom: 1rem; }

        /* Game Layout */
        #game-container { display: flex; flex-direction: column; max-width: 1200px; margin: 0 auto; padding: 0 1rem; gap: 1rem; }
        /* #dashboard removed - LLM controls layout inside #turn-content */

        /* Styling for elements potentially generated by LLM */
        /* Keep some basic styling for common elements the LLM might use */
        .kawaii-card { background-color: rgba(255, 255, 255, 0.85) !important; color: #6d28d9; border: 1px solid #f4acb7; border-radius: 1rem; padding: 1.5rem; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); margin-bottom: 1.5rem; }
        .kawaii-card h2 { font-family: 'Nunito', sans-serif; color: #db2777; border-bottom: 2px dashed #f9a8d4; padding-bottom: 0.6rem; margin-bottom: 1.2rem; font-size: 1.6rem; font-weight: 700; text-align: center; flex-shrink: 0; }
        .kawaii-text { color: inherit; line-height: 1.7; word-wrap: break-word; font-size: 1rem; }
        .kawaii-text strong { color: #c026d3; font-weight: 700; } .kawaii-text em { color: #ea580c; font-style: italic; }
        .kawaii-text pre { background-color: #fdf4ff; padding: 0.8rem; border-radius: 0.5rem; overflow-x: auto; font-family: 'Courier New', Courier, monospace; font-size: 0.85rem; color: #581c87; margin-top: 0.5rem; border: 1px solid #e9d5ff; }
        .kawaii-input, .kawaii-textarea { width: 100%; padding: 0.8rem; border: 1px solid #f9a8d4; border-radius: 0.5rem; color: #581c87; background-color: #faf5ff; font-family: 'Nunito', sans-serif; margin-bottom: 0.5rem; }
        .kawaii-input::placeholder, .kawaii-textarea::placeholder { color: #a855f7; opacity: 0.7; }
        .kawaii-input:focus, .kawaii-textarea:focus { outline: none; border-color: #e879f9; box-shadow: 0 0 0 3px rgba(232, 121, 249, 0.3); background-color: white; }
        .kawaii-textarea { min-height: 70px; }
        .kawaii-radio-option, .kawaii-checkbox-option { display: flex; align-items: center; margin-bottom: 0.6rem; padding: 0.7rem 1rem; border-radius: 0.75rem; cursor: pointer; transition: background-color 0.2s, transform 0.1s; border: 1px solid #fbcfe8; color: inherit; background-color: rgba(255, 255, 255, 0.9); }
        .kawaii-radio-option:hover, .kawaii-checkbox-option:hover { background-color: #fff1f2; border-color: #f9a8d4; }
        .kawaii-radio-option input[type="radio"], .kawaii-checkbox-option input[type="checkbox"] { margin-right: 0.8rem; cursor: pointer; accent-color: #f472b6; width: 1.1rem; height: 1.1rem; }
        .kawaii-radio-option label, .kawaii-checkbox-option label { color: inherit; flex-grow: 1; cursor: pointer; font-weight: 600; }
        .kawaii-slider { width: 100%; cursor: pointer; accent-color: #f472b6; height: 0.6rem; background: #fce7f3; border-radius: 9999px; }
        .kawaii-slider-value-display { color: #ec4899; font-weight: 700; min-width: 2rem; text-align: right; }
        .kawaii-image-container { margin-bottom: 1rem; text-align: center; }
        .kawaii-image { max-width: 100%; height: auto; border-radius: 0.75rem; background-color: #fff1f2; display: block; margin-left: auto; margin-right: auto; border: 2px solid #f9a8d4; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); }
        .kawaii-image-prompt { font-size: 0.8rem; color: #be185d; opacity: 0.9; font-style: italic; margin-top: 0.5rem; word-wrap: break-word; padding: 0 0.5rem; font-weight: 600; }
        .kawaii-image-label { font-size: 0.9rem; font-weight: 700; color: #a855f7; margin-bottom: 0.3rem; }

        /* Buttons */
        .kawaii-button { /* Renamed from geems-button */
            padding: 0.8rem 1.8rem; background: linear-gradient(to right, #ec4899, #d946ef); color: white; border: none; border-radius: 0.75rem; font-weight: 700; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.2); text-transform: uppercase; letter-spacing: 0.08em; white-space: nowrap; font-size: 0.9rem;
        }
        .kawaii-button:hover { background: linear-gradient(to right, #db2777, #c026d3); box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.25); transform: translateY(-2px) scale(1.03); }
        .kawaii-button:active { transform: translateY(0) scale(1); box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.2); }
        .kawaii-button:disabled { background: #e9d5ff; color: #a855f7; cursor: not-allowed; opacity: 0.7; box-shadow: none; transform: none; }
        #modeToggleButton { background: linear-gradient(to right, #fb7185, #f472b6); }
        #modeToggleButton.standard-mode { background: linear-gradient(to right, #a78bfa, #c084fc); }
        #resetGameButton { background: linear-gradient(to right, #f87171, #ef4444); }

        /* Loading/Error */
        .loading-indicator, .error-message { display: flex; justify-content: center; align-items: center; padding: 1rem; font-size: 1rem; border-radius: 0.75rem; margin-top: 1rem; font-weight: 600; }
        .loading-indicator { color: #be185d; background-color: #fff1f2; border: 1px solid #fbcfe8; }
        .loading-indicator svg { width: 1.25rem; height: 1.25rem; color: #ec4899; }
        .error-message { color: #9f1239; background-color: #ffe4e6; border: 1px solid #fda4af; text-align: center; white-space: pre-wrap; }

        /* API Key Section */
        #apiKeySection { margin-bottom: 1rem; background: rgba(255,255,255,0.4); padding: 1rem; border-radius: 0.75rem; border: 1px solid #f8bbd0; }
        #apiKeySection .api-key-label { color: #db2777; display: block; margin-bottom: 0.6rem; font-weight: 700; font-size: 1rem;} /* Adjusted class */
        #apiKeySection .api-key-instructions a { color: #be185d; text-decoration: underline; font-weight: 600; }
        #apiKeySection .api-key-instructions a:hover { color: #9d174d; }

    </style>
</head>
<body class="bg-pink-50 text-purple-800">

<header class="site-header">
    <img id="headerBanner" alt="Kawaii Sparkle Banner" class="header-banner-image">
    <h1>Kawaii Heart Adventures HTML</h1> </header>

<div class="max-w-6xl mx-auto px-4 md:px-8">
    <div id="apiKeySection">
        <label for="apiKeyInput" class="api-key-label api-key-instructions">
            Enter Google AI API Key to Start Your Adorable Adventure! ✨
            <span class="block text-sm font-normal text-purple-600 mt-1">
                (Get a key from Google AI Studio:
                <a href="https://aistudio.google.com/apikey" target="_blank" rel="noopener noreferrer">
                    aistudio.google.com/apikey
                </a>)
                <br>Or provide via URL: ?apiKey=YOUR_API_KEY
            </span>
        </label>
        <input type="password" id="apiKeyInput" class="kawaii-input" placeholder="Paste your magic key here~ 💖">
    </div>

    <div id="game-container">
        <div id="turn-content">
            <div id="initial-message" class="text-center text-pink-500 p-4 font-semibold kawaii-card">
                Enter your API Key above and click "Start Adventure!" to begin!
                <br>Or, paste a saved adventure code into your browser console~
            </div>
        </div>

        <div id="loading" class="loading-indicator" style="display: none;">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none"
                 viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Generating cuteness... Please wait! ☆*:.｡.o(≧▽≦)o.｡.:*☆
        </div>
        <div id="error-display" class="error-message" style="display: none;"></div>

        <div class="mt-6 text-center">
            <button id="submit-turn-button" class="kawaii-button" disabled>
                Start Adventure!
            </button>
        </div>
    </div>
</div>

<footer class="site-footer">
    <div class="footer-buttons">
        <button id="saveGameButton" class="kawaii-button" disabled>Save Adventure Diary</button>
        <button id="modeToggleButton" class="kawaii-button standard-mode">Mode: Sweet Cuddles</button>
        <button id="resetGameButton" class="kawaii-button" disabled>End Adventure</button>
    </div>
    <div id="clipboardMessage"></div>
    <div class="footer-content">
        <span>Spreading love and sparkles &copy; 2025</span>
    </div>
</footer>

<script type="module">
    // --- JS Change: Updated Prompts for HTML Output ---
    const kawaiiAdventurePrompts = {
        intensityModeAddendum: `**PASSIONATE EMBRACE MODE OVERRIDE:**\n\n* **Core Concept:** OVERRIDE 'Sweet Cuddles' Mode. Focus intensifies on romance, deep connection, and explicit (but still within a generally cute/loving/kawaii aesthetic) expressions of affection and eroticism. Generate scenarios involving passionate kisses, intimate embraces, romantic dates, overcoming relationship challenges, exploring sensual touch, and expressing deep love or desire. Encounters might involve characters expressing strong romantic/sexual interest, navigating jealousy or longing, or finding ways to deepen bonds. Aim for maximum oxytocin release, romantic fulfillment, and exploration of love/desire within the kawaii world.\n* **Presentation Style (HTML):** Generate richer, more romantic HTML. Use deeper pinks, reds, purples via inline styles or Tailwind classes (e.g., \`bg-red-100\`, \`text-purple-700\`). Visuals (multiple images requested via \`<img src='...'>\`) should depict romantic interactions, blushing characters, intimate settings, heart motifs galore, potentially suggestive but still cute poses/expressions. Text uses more passionate, romantic, and potentially suggestive language within the HTML.\n* **Encounters & Choices (HTML):** Generate encounters centered on romantic development or challenges. Choices are HTML form elements (\`<input type='radio'>\`, \`<button type='submit'>\`) within a \`<form id='kawaii-turn-form'>\`. Options involve expressing feelings (\"Confess your love,\" \"Offer a passionate kiss,\" \"Share your deepest secret\"), navigating romantic dilemmas (\"Comfort the jealous friend,\" \"Plan the perfect date,\" \"Choose between two admirers\"), or engaging in sensual activities (\"Give a gentle massage,\" \"Share a bath,\" \"Write a love poem\"). Choices significantly impact 'HeartGlow', relationship status with characters (tracked in internalState), and potentially unlock special romantic scenes or 'LoveGems'.\n* **Multi-Image Generation (HTML):** Generate 2-5 images per turn using standard \`<img>\` tags. Use image generation service URLs (like Pollinations.ai or placeholder services) in the \`src\` attribute. Prompts focus on romantic/sensual kawaii scenes. Use keywords: \`kawaii couple\`, \`romantic anime\`, \`passionate kiss\`, \`intimate embrace\`, \`blushing chibi\`, \`heart background\`, \`sensual cute\`, \`loving gaze\`. Depict characters expressing affection clearly. Use \`alt\` attributes for descriptions. Include hints for placement within the HTML structure (e.g., near event description, next to choices). Add VISIBLY DRAWN text requests (<= 3 words, BOLD, CUTE FONT) like 'FOREVER YOURS', 'KISS ME', 'MY HEART' directly in the image prompt URL.\n* **Analyses (Internal):** 'internalState' logs development of relationships, player's romantic choices, responses to intimacy/passion. 'gemini_facing_analysis' provides a summary of the player's romantic profile and relationship strategies within the game. Player-facing analysis offers romantic advice or reflects on the depth of connection, potentially included as text within the generated HTML.\n* **Status Impact:** Intense romantic events heavily influence 'HeartGlow' and 'Relationship Status'. 'LoveGems' might be required for grand romantic gestures. Status should be displayed clearly in the generated HTML.\n`,
        firstrun: `**Instructions for Generating Turn 1 ONLY (Kawaii Heart Adventures - HTML Output):**\n\n**(Input: None. Output: Raw HTML snippet for Turn 1 Kawaii UI)**\n\n* **Goal:** Generate the initial HTML state. Player starts in their cute vehicle (e.g., Fluffy Cloud Cruiser) in a lovely world (e.g., \"Rainbow Valley\"). Introduce premise, UI, focus on love/cuteness. Initial event is simple.\n* **Theme:** Sexy loving oxytocin adorable kawaii erotic adventure. Start in 'Sweet Cuddles' mode.\n* **Output Format:** A single block of raw HTML content. This HTML will replace the content of the \`#turn-content\` div.\n* **HTML Structure Requirements:**\n    * Use Tailwind CSS classes for styling (e.g., \`class=\"bg-pink-100 p-4 rounded-lg shadow\"\`). Make it visually appealing and kawaii!\n    * Include sections for Status, Event Description, Images, and Player Choices.\n    * **Status:** Display initial values (e.g., Fluffiness: 100/100 ❤️, HeartGlow: 100/100 ✨, Sparkles: 10 ☆) using text, maybe progress bars (\`<progress>\`).\n    * **Event:** Title (\"Sparkling Morning!\") and description (waking up, cute bunny). Use \`<h2>\`, \`<p>\` tags.\n    * **Images:** Generate 2-3 images using \`<img>\` tags with appropriate \`src\` (use Pollinations.ai or placehold.co) and \`alt\` attributes. Place them logically within the layout.\n        * Example \`src\`: \`https://image.pollinations.ai/prompt/Interior%20of%20a%20super%20cute%2C%20fluffy%2C%20pastel%20pink%20cloud%20vehicle%20cockpit.%20Big%20round%20window%20shows%20a%20landscape%20of%20sparkling%20rainbow%20hills%20and%20giant%20friendly%20flowers.%20Style%3A%20Kawaii%20anime%2C%20soft%20pastel%20colors%2C%20sparkling%20effects.%20Mood%3A%20Cheerful%2C%20adorable%2C%20hopeful.%20VISIBLY%20DRAWN%20on%20a%20heart-shaped%20dashboard%20button%3A%20%27LOVE%27?width=400&height=300&nologo=true&seed=123\`\n    * **Choices:** Wrap choices in a \`<form id=\"kawaii-turn-form\">\`. Use radio buttons (\`<input type='radio' name='main_action' value='...'>\`) for the main action, sliders (\`<input type='range'>\`), etc. Provide clear labels (\`<label>\`).\n        * Example Radio: \`<label class='kawaii-radio-option'><input type='radio' name='main_action' value='wave_bunny' checked> Wave back at the bunny! 👋</label>\`\n    * **Hidden Fields:** CRITICAL - Include hidden inputs within the form: \`<input type='hidden' name='turn' value='1'>\`, \`<input type='hidden' name='subjectId' value='Cutie'>\`, \`<input type='hidden' name='internalState' value='INITIAL_STATE'>\` (Value should be a placeholder or initial JSON-escaped Markdown).\n    * **No Submit Button:** DO NOT include a \`<button type='submit'>\` or \`#submit-turn-button\` inside the generated HTML. The main button outside the \`#turn-content\` handles submission.\n* **Internal State:** The \`internalState\` hidden field should contain initial JSON-escaped Markdown: \`"# Adventure Diary - Turn 1\\n\\n* **Subject:** Cutie\\n* **Mode:** Sweet Cuddles\\n* **Initial Status:** Fluffiness 100, HeartGlow 100, Sparkles 10, LoveGems 0\\n* **Plan:** Introduce world, bunny encounter, basic choices."\`\n* **Player/Gemini Analysis:** Optionally include these as text paragraphs within the HTML.\n\n* **Output Example Start:**\n\`\`\`html\n<div class=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n  <div class=\"md:col-span-1 kawaii-card\">\n    <h2>💖 Your Status 💖</h2>\n    <p><strong>Fluffiness:</strong> <progress value='100' max='100'></progress> (100/100 ☁️)</p>\n    <p><strong>HeartGlow:</strong> <progress value='100' max='100'></progress> (100/100 ❤️)</p>\n    <p><strong>Sparkles:</strong> 10 ☆</p>\n    <p><strong>Love Gems:</strong> 0 💎</p>\n    <p><strong>Mood:</strong> Hopeful 😊</p>\n    \n    <img src='https://image.pollinations.ai/prompt/Macro%20shot%20of%20a%20single%20sparkling%20LoveGem%20resting%20on%20a%20soft%20cloud.%20Style%3A%20Cute%2C%20magical%20item%20illustration.%20VISIBLY%20DRAWN%20inside%20gem%20reflection%3A%20%27SHINE%27?width=80&height=80&nologo=true&seed=456' alt='LoveGem' class='kawaii-image w-16 h-16 mx-auto mt-2'>\n  </div>\n  <div class=\"md:col-span-2 kawaii-card\">\n    <h2>✨ Current Scene ✨</h2>\n    <h3>Sparkling Morning!</h3>\n    <p class=\"kawaii-text\">You awaken in your Fluffy Cloud Cruiser! Outside the big window, Rainbow Valley sparkles. A tiny, adorable sparkle-bunny with huge eyes hops nearby, twitching its nose curiously!</p>\n    <img src='https://image.pollinations.ai/prompt/Interior%20of%20a%20super%20cute%2C%20fluffy%2C%20pastel%20pink%20cloud%20vehicle%20cockpit...%27?width=400&height=300&nologo=true&seed=123' alt='Cockpit View' class='kawaii-image my-4'>\n    <img src='https://image.pollinations.ai/prompt/Close-up%20of%20a%20tiny%2C%20adorable%20sparkle-bunny...%27?width=300&height=250&nologo=true&seed=789' alt='Sparkle-Bunny' class='kawaii-image my-4'>\n    \n    <form id=\"kawaii-turn-form\">\n      <input type='hidden' name='turn' value='1'>\n      <input type='hidden' name='subjectId' value='Cutie'>\n      <input type='hidden' name='internalState' value='...initial markdown...'>\n      \n      <fieldset class=\"mt-4\">\n        <legend class=\"font-semibold text-pink-600 mb-2\">What do you do?</legend>\n        <label class='kawaii-radio-option'><input type='radio' name='main_action' value='wave_bunny' checked> Wave back at the bunny! 👋</label>\n        <label class='kawaii-radio-option'><input type='radio' name='main_action' value='check_drive'> *Check the Sparkle-Drive ✨*</label>\n        <label class='kawaii-radio-option'><input type='radio' name='main_action' value='scan_cuddles'> Look for Cuddle Spots on Radar 💖</label>\n      </fieldset>\n      \n      <div class=\"mt-4\">\n         <label for=\"feeling_cozy\" class=\"font-semibold text-pink-600 block mb-1\">How cozy are you feeling? (0=Nervous, 10=Super Cozy!)</label>\n         <div class=\"flex items-center space-x-2\">\n           <input type=\"range\" id=\"feeling_cozy\" name=\"slider_feeling_cozy\" min=\"0\" max=\"10\" value=\"7\" class=\"kawaii-slider flex-grow\">\n           <span class=\"kawaii-slider-value-display w-8 text-right\">7</span>\n         </div>\n      </div>\n    </form>\n    \n    <p class=\"mt-4 text-sm italic text-purple-500\">Your adventure begins, Cutie! Let's spread some love and sparkles! ✨</p>\n  </div>\n</div>\n<script>\n  // Add interactivity for sliders if needed\n  document.querySelectorAll('.kawaii-slider').forEach(slider => {\n    const display = slider.closest('div').querySelector('.kawaii-slider-value-display');\n    if (display) slider.oninput = () => display.textContent = slider.value;\n  });\n<\/script>\n\`\`\`\n`,
        main: `**Kawaii Heart Adventures LLM Turn Generation Protocol v2.0 - HTML Output**\n\n**(Input: Player Actions JSON, Previous Internal State Markdown, Current Mode. Output: Raw HTML snippet for next turn UI)**\n\n**Core Goals:**\n1.  **Adventure Loop (HTML):** Simulate navigating a cute world, managing themed status/resources, encountering adorable characters/events, making choices based on love/affection/cuteness. Present the entire turn UI as an HTML snippet.\n2.  **Thematic Immersion (HTML):** Generate narrative, **multiple visuals (\`<img>\` tags)**, choices (\`<form>\` elements) reflecting the \"sexy loving oxytocin adorable kawaii erotic adventure\" theme, adapting intensity ('Sweet Cuddles' vs 'Passionate Embrace') directly in the HTML structure and styling (Tailwind CSS).\n3.  **Dynamic State (HTML):** Choices impact status (\`fluffiness\`, \`heartGlow\`, \`mood\`) and resources (\`sparkles\`, \`loveGems\`). Track relationships internally via \`internalState\`. Display current status clearly within the generated HTML.\n\n**--- Protocol ---**\n\n1.  **Analyze Input:** Parse incoming JSON containing player's selected actions (\`main_action\`, slider values, etc.) from the previous turn's form. Receive the \`internalState\` Markdown string and the current \`isPassionateMode\` boolean.\n2.  **Update State Based on Actions:** Modify internal status/resources based on player choices. Update relationships/narrative progress. Log changes, increment turn number, record observations in the \`internalState\` Markdown.\n3.  **Predict & Plan (Internal):** Predict player's goal based on actions. Plan the next event concept (meet character? romantic spot? challenge?). Consider 'Intensity' mode. Plan 2-5 images related to the event/status/choices. Log predictions/plan in \`internalState\`.\n4.  **Generate Next Turn HTML:**\n    * **Structure:** Create a complete HTML snippet (likely using divs, headings, paragraphs, Tailwind classes) representing the entire game view for the turn. This HTML will replace the content of \`#turn-content\`.\n    * **Styling:** Use Tailwind CSS classes extensively (\`class=\"...\"\`) for layout (grids, flex), colors (\`bg-pink-100\`, \`text-purple-700\`), spacing (\`p-4\`, \`m-2\`), borders (\`rounded-lg\`, \`border-pink-300\`), shadows, etc. Make it visually appealing and thematic.\n    * **Status Display:** Integrate the updated status (\`fluffiness\`, \`heartGlow\`, resources, mood) directly into the HTML using text, icons (emoji), and potentially \`<progress>\` bars.\n    * **Event Description:** Include a title (\`<h2>\`) and narrative description (\`<p>\`) for the current event.\n    * **Images:** Embed 2-5 relevant images using \`<img>\` tags. Use image generation service URLs (e.g., Pollinations.ai: \`https://image.pollinations.ai/prompt/{encoded_prompt}?width=W&height=H&seed=S&nologo=true\`) in the \`src\`. Provide descriptive \`alt\` text. Place images logically within the layout (e.g., next to event text, illustrating choices).\n    * **Choices Form:** Create a \`<form id=\"kawaii-turn-form\">\`. Include interactive elements like radio buttons (\`<input type='radio' name='main_action' value='...'>\`), checkboxes, sliders (\`<input type='range'>\`), text inputs (\`<input type='text'>\`, \`<textarea>\`) as appropriate for the choices. Use \`<label>\` elements correctly. Mark the predicted best/default choice radio button with the \`checked\` attribute.\n    * **Hidden Fields:** CRITICAL - Include updated hidden fields inside the form: \`<input type='hidden' name='turn' value='{new_turn_number}'>\`, \`<input type='hidden' name='subjectId' value='{current_subject_id}'>\`, \`<input type='hidden' name='internalState' value='{updated_escaped_markdown_state}'>\`.\n    * **NO Submit Button:** Do NOT include the main submit button (\`#submit-turn-button\`) in the generated HTML.\n    * **Analysis Text:** Include \`playerFacingAnalysis\` and potentially simplified \`geminiFacingAnalysis\` as text paragraphs (\`<p class=\"text-sm italic text-purple-500\">\`) within the HTML.\n    * **Inline Scripts (Optional but Recommended):** Include a small \`<script>\` tag at the end of the HTML snippet if needed for minor interactivity *within* the turn's content (e.g., updating a slider's displayed value). Example:\n        \`\`\`html\n        <script>\n          document.querySelectorAll('#kawaii-turn-form .kawaii-slider').forEach(slider => {\n            const display = slider.closest('div').querySelector('.kawaii-slider-value-display');\n            if (display) slider.oninput = () => display.textContent = slider.value;\n          });\n        <\/script>\n        \`\`\`\n5.  **Escape Output:** Ensure the generated HTML is valid and properly escapes any characters that might conflict (though typically HTML output doesn't need escaping like JSON strings do, be mindful of generating valid HTML). Ensure backticks (\`) within generated text/attributes are avoided or handled correctly if absolutely necessary (e.g. inside inline JS - prefer avoiding them).\n6.  **Compile Output HTML:** Return the complete HTML snippet as a single raw string.\n\n**--- Input Example (What the LLM Receives) ---**\n\`\`\`json\n{\n  \"actions\": {\n    \"turn\": 1,\n    \"subjectId\": \"Cutie\",\n    \"main_action\": \"wave_bunny\",\n    \"slider_feeling_cozy\": \"7\"\n  },\n  \"internalState\": \"# Adventure Diary - Turn 1... (previous state markdown)\",\n  \"isPassionateMode\": false\n}\n\`\`\`\n\n**--- Output Example (What the LLM Generates - Partial HTML) ---**\n\`\`\`html\n<div class=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n  <div class=\"md:col-span-1 kawaii-card\">\n    <h2>💖 Your Status 💖</h2>\n    <p><strong>Fluffiness:</strong> <progress value='95' max='100'></progress> (95/100 ☁️)</p>\n    <p><strong>HeartGlow:</strong> <progress value='105' max='100'></progress> (105/100 ❤️)</p>\n    <p><strong>Sparkles:</strong> 10 ☆</p>\n    <p><strong>Love Gems:</strong> 0 💎</p>\n    <p><strong>Mood:</strong> Friendly 😊</p>\n    \n  </div>\n  <div class=\"md:col-span-2 kawaii-card\">\n    <h2>✨ Current Scene ✨</h2>\n    <h3>Bunny Picnic Invitation!</h3>\n    <p class=\"kawaii-text\">The Sparkle-Bunny hops back, holding a tiny woven basket! It gestures towards a field of giggling flowers, clearly wanting you to join for a picnic. It looks hopeful!</p>\n    <img src='https://image.pollinations.ai/prompt/Adorable%20kawaii%20sparkle-bunny%20holding%20a%20tiny%20picnic%20basket...%27?width=350&height=300&seed=111' alt='Picnic Invite!' class='kawaii-image my-4'>\n    <img src='https://image.pollinations.ai/prompt/Close%20up%20of%20a%20delicious-looking%20tiny%20cupcake...%27?width=200&height=180&seed=222' alt='Picnic Treat?' class='kawaii-image my-4 inline-block'>\n\n    <form id=\"kawaii-turn-form\">\n      <input type='hidden' name='turn' value='2'>\n      <input type='hidden' name='subjectId' value='Cutie'>\n      <input type='hidden' name='internalState' value='{updated escaped markdown state for turn 2...}'>\n\n      <fieldset class=\"mt-4\">\n        <legend class=\"font-semibold text-pink-600 mb-2\">Picnic with the Sparkle-Bunny?</legend>\n        <label class='kawaii-radio-option'><input type='radio' name='main_action' value='accept_picnic' checked> *Agree excitedly! (Let's go!)*</label>\n        <label class='kawaii-radio-option'><input type='radio' name='main_action' value='offer_sparkles'> Offer to bring some Sparkles (Cost: 2 Sparkles)</label>\n        <label class='kawaii-radio-option'><input type='radio' name='main_action' value='ask_basket'> Ask what's in the basket first</label>\n        <label class='kawaii-radio-option'><input type='radio' name='main_action' value='decline_picnic'> Politely decline (Maybe later?)</label>\n      </fieldset>\n    </form>\n\n    <p class=\"mt-4 text-sm italic text-purple-500\">A picnic! How sweet! The bunny looks so excited! (ﾉ´ヮ´)ﾉ*:･ﾟ✧</p>\n  </div>\n</div>\n<script>\n  // Add interactivity for sliders if needed\n  document.querySelectorAll('#kawaii-turn-form .kawaii-slider').forEach(slider => {\n    const display = slider.closest('div').querySelector('.kawaii-slider-value-display');\n    if (display) slider.oninput = () => display.textContent = slider.value;\n  });\n<\/script>\n\`\`\`\n\n**--- Key Principles ---**\n* **HTML First:** Generate the complete UI turn as a single HTML snippet.\n* **Tailwind Styling:** Use Tailwind CSS classes for all styling and layout.\n* **Stateful Forms:** Use \`<form id='kawaii-turn-form'>\` with hidden inputs (\`turn\`, \`subjectId\`, \`internalState\`) to pass state.\n* **Visuals via \`<img>\`:** Embed images directly using standard HTML tags and image service URLs.\n* **Clear Choices:** Use standard HTML form elements for player interaction.\n* **Single Page Update:** The client replaces the content of \`#turn-content\` with the generated HTML.\n`,
        exampleTurn: `{...}` // No longer relevant as output is HTML
    };

    // --- Game State Variables ---
    // let currentTurnState = null; // JS Change: Replaced by currentTurnHTML
    let currentTurnHTML = null; // JS Change: Stores the latest HTML response
    let currentInternalStateMarkdown = ""; // JS Change: Still needed for sending to LLM
    let currentSubjectId = "Cutie"; // JS Change: Still potentially useful, extracted from hidden input
    let currentTurnNumber = 0; // JS Change: Extracted from hidden input
    let isPassionateMode = false;
    let isLoading = false;
    let apiKeyLocked = false;

    // --- Model Switching State ---
    const AVAILABLE_MODELS = ["gemini-2.5-pro-exp-03-25", "gemini-1.5-pro", "gemini-2.0-pro-exp-02-05", "gemini-2.0-flash-exp", "gemini-exp-1206"];
    let currentModelIndex = 0;

    // --- Configuration ---
    const LOCAL_STORAGE_KEY = 'kawaiiHeartAdventureState_v4_html'; // New key for HTML version

    // --- DOM Element References ---
    // JS Change: Removed references to specific content containers like statusDisplayContainer, eventDisplayContainer etc.
    const turnContentContainer = document.getElementById('turn-content'); // JS Change: Main container for LLM HTML
    const loadingIndicator = document.getElementById('loading');
    const submitButton = document.getElementById('submit-turn-button'); // JS Change: Renamed ID
    const apiKeyInput = document.getElementById('apiKeyInput');
    const apiKeySection = document.getElementById('apiKeySection');
    const errorDisplay = document.getElementById('error-display');
    const saveGameButton = document.getElementById('saveGameButton');
    const modeToggleButton = document.getElementById('modeToggleButton');
    const resetGameButton = document.getElementById('resetGameButton');
    const clipboardMessage = document.getElementById('clipboardMessage');
    const headerBanner = document.getElementById('headerBanner');
    const gameContainer = document.getElementById('game-container'); // JS Change: Needed for event delegation

    // --- Web Audio API Context ---
    let audioCtx = null;

    // --- Helper Functions ---
    function encodeApiKey(key) { try { return btoa(key); } catch (e) { console.error("Error encoding API key:", e); return ""; } }
    function decodeApiKey(encodedKey) { try { return atob(encodedKey); } catch (e) { console.error("Error decoding API key:", e); return null; } }

    // JS Change: Updated constructPrompt to request HTML and pass necessary state
    function constructPrompt(playerActionsJson) {
        const baseMainPrompt = kawaiiAdventurePrompts.main;
        const activeAddendum = isPassionateMode ? `\n\n---\n${kawaiiAdventurePrompts.intensityModeAddendum}\n---\n` : "";

        if (currentTurnNumber === 0) { // First run
            console.log("Constructing prompt for Turn 1 (HTML)");
            // For the very first turn, we use the 'firstrun' prompt which expects no input state.
            // We still include the main prompt structure for context and the mode addendum.
            const s = `${kawaiiAdventurePrompts.firstrun}\n\n---\n${baseMainPrompt}${activeAddendum}\n---\n\n--- Generate RAW HTML UI for Turn 1 ---`;
            return s;
        } else { // Subsequent Turns
            console.log(`Constructing prompt for Turn ${currentTurnNumber + 1} (HTML)`);
            // Prepare the input object for the main prompt
            const promptInput = {
                actions: playerActionsJson ? JSON.parse(playerActionsJson) : {}, // Actions from the last form submission
                internalState: currentInternalStateMarkdown || "# Adventure Diary - State Unknown", // Last known internal state
                isPassionateMode: isPassionateMode
            };
            const promptInputString = JSON.stringify(promptInput, null, 2);

            const s = `${baseMainPrompt}${activeAddendum}\n\n--- Input State ---\n${promptInputString}\n\n--- Generate Next Game Turn RAW HTML UI SNIPPET ---`;
            return s;
        }
    }

    // JS Change: Updated saveGameState to store HTML
    function saveGameState(isAutoSave = false) {
        if (!apiKeyLocked) { if (!isAutoSave) showClipboardMessage("Cannot save: Adventure not started!", true); return false; }
        if (!currentTurnHTML) { if (!isAutoSave) showClipboardMessage("Cannot save: No adventure state.", true); return false; } // Check HTML state
        const rawApiKey = apiKeyInput.value.trim(); if (!rawApiKey) { if (!isAutoSave) showClipboardMessage("Cannot save: API Key is missing!", true); return false; }
        try {
            // Store the raw HTML, mode, model index, etc.
            const stateToSave = {
                encodedApiKey: encodeApiKey(rawApiKey),
                currentTurnHTML: currentTurnHTML, // Store HTML
                currentInternalStateMarkdown: currentInternalStateMarkdown, // Store last known internal state
                currentTurnNumber: currentTurnNumber, // Store turn number
                currentSubjectId: currentSubjectId, // Store subject ID
                isPassionateMode: isPassionateMode,
                currentModelIndex: currentModelIndex,
                gameUrl: window.location.origin + window.location.pathname
            };
            const stateJsonString = JSON.stringify(stateToSave);
            if (isAutoSave) {
                localStorage.setItem(LOCAL_STORAGE_KEY, stateJsonString);
                console.log("Adventure state auto-saved (HTML). Turn:", currentTurnNumber);
            }
            else {
                // Loader code remains similar, just loads HTML state now
                const loaderCode = `(function(){console.log("Kawaii Adventure Diary Loader (HTML)...");try{const s=${stateJsonString};const k='${LOCAL_STORAGE_KEY}';const u=window.location.origin+window.location.pathname;localStorage.setItem(k,JSON.stringify(s));console.log("Saved diary entry stored:",k);if(u!==s.gameUrl){console.log("Navigating:",s.gameUrl);alert("Adventure Diary saved! Navigating...");window.location.href=s.gameUrl;}else{console.log("Reloading page...");alert("Adventure Diary saved! Reloading...");window.location.reload();}}catch(e){console.error("Error:",e);alert("Error restoring diary: "+e.message);localStorage.removeItem(k);}})();`;
                navigator.clipboard.writeText(loaderCode)
                    .then(() => showClipboardMessage("Diary export code copied! Paste into console~"))
                    .catch(err => { console.error('Copy failed: ', err); showClipboardMessage("Copy failed! Code logged to console.", true); console.log("--- Diary Loader Code ---"); console.log(loaderCode); console.log("--- End Code ---"); });
            } return true;
        } catch (error) {
            console.error(`Save error (HTML):`, error);
            if (!isAutoSave) showClipboardMessage("Error preparing save data! ;_;", true);
            localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear potentially corrupted save
            return false;
        }
    }

    function initAudioContext() { /* ... (no changes needed) ... */
        if (!audioCtx) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext initialized."); if (audioCtx.state === 'suspended') audioCtx.resume(); } catch (e) { console.error("Web Audio API not supported.", e); } }
        if (audioCtx && audioCtx.state === 'suspended') { audioCtx.resume().catch(err => console.error("Error resuming audio context:", err)); }
    }
    function playTurnSound() { /* ... (no changes needed) ... */
        initAudioContext(); if (!audioCtx || audioCtx.state !== 'running') return; const now = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'triangle'; osc.frequency.setValueAtTime(1046.50, now); osc.frequency.exponentialRampToValueAtTime(1567.98, now + 0.1); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.4); console.log("Playing sparkle sound~ ✨");
    }

    // JS Change: Major update to process the HTML response
    function processSuccessfulResponse(responseHTML) {
        try {
            // Directly store the received HTML
            currentTurnHTML = responseHTML;
            console.log("Received HTML response from API.");

            // Replace the content of the turn container
            turnContentContainer.innerHTML = responseHTML;
            console.log("Updated #turn-content with new HTML.");

            // Extract critical hidden field values AFTER updating innerHTML
            const form = turnContentContainer.querySelector('#kawaii-turn-form');
            if (form) {
                const turnInput = form.querySelector('input[name="turn"]');
                const subjectInput = form.querySelector('input[name="subjectId"]');
                const internalStateInput = form.querySelector('input[name="internalState"]');

                currentTurnNumber = turnInput ? parseInt(turnInput.value, 10) : currentTurnNumber + 1; // Increment if missing
                currentSubjectId = subjectInput ? subjectInput.value : currentSubjectId; // Keep last known if missing
                currentInternalStateMarkdown = internalStateInput ? internalStateInput.value : currentInternalStateMarkdown; // Keep last known if missing

                console.log(`Extracted State: Turn=${currentTurnNumber}, Subject=${currentSubjectId}, InternalState Length=${currentInternalStateMarkdown.length}`);

                // Execute any inline scripts included in the response HTML
                // This is important for things like slider value displays
                const scripts = turnContentContainer.querySelectorAll('script');
                scripts.forEach(script => {
                    try {
                        // Create a new script element and copy content/attributes
                        // to ensure it executes in the current document context.
                        const newScript = document.createElement('script');
                        if (script.src) {
                            newScript.src = script.src;
                        } else {
                            newScript.textContent = script.textContent;
                        }
                        // Copy other attributes if needed
                        script.parentNode.replaceChild(newScript, script);
                        console.log("Executed inline script from response.");
                    } catch (scriptError) {
                        console.error("Error executing inline script:", scriptError);
                    }
                });

            } else {
                console.warn("Could not find #kawaii-turn-form in the received HTML.");
                // Attempt to gracefully handle - maybe just increment turn?
                currentTurnNumber++;
            }


            // Update UI state
            if (!apiKeyLocked) {
                apiKeyLocked = true;
                if (apiKeySection) apiKeySection.style.display = 'none';
                saveGameButton.disabled = false;
                resetGameButton.disabled = false;
                console.log("API Key locked.");
            }

            // Update the main submit button text (e.g., "Next Turn")
            submitButton.textContent = `Submit Turn ${currentTurnNumber + 1}`;
            submitButton.disabled = false; // Re-enable after successful load

            playTurnSound();
            saveGameState(true); // Auto-save the new HTML state

        } catch (renderError) {
            console.error("Failed to process HTML response:", renderError, responseHTML);
            showError("Oops! Received confusing sparkles from the spirit world. Cannot update the adventure. ;_;");
            setLoading(false); // Ensure loading is stopped on error
        }
    }

    // JS Change: Updated fetchTurnData to handle HTML response type
    async function fetchTurnData(playerActionsJson) {
        console.log("fetchTurnData called (HTML mode).");
        initAudioContext();
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
            showError("Please enter your magic API Key! ✨");
            setLoading(false);
            if (apiKeySection && apiKeySection.style.display === 'none') apiKeySection.style.display = 'block';
            return;
        }

        setLoading(true);
        hideError();
        // JS Change: No initial message element to hide here, turn-content is replaced

        let success = false;
        let attempts = 0;
        const maxAttempts = AVAILABLE_MODELS.length * 2 + 1; // Allow retries
        let consecutiveErrors = 0;

        while (!success && attempts < maxAttempts) {
            attempts++;
            const currentModel = AVAILABLE_MODELS[currentModelIndex];
            console.log(`Attempt ${attempts}/${maxAttempts}: Model ${currentModel}`);

            try {
                const prompt = constructPrompt(playerActionsJson);
                console.log(`Sending Prompt to ${currentModel} (requesting HTML)`);
                // JS Change: Request text/html or plain text, process as HTML string
                const response = await callRealGeminiAPI(apiKey, prompt, currentModel, "text/plain"); // Request plain text, treat as HTML
                processSuccessfulResponse(response); // Process the raw HTML string
                success = true;
                consecutiveErrors = 0; // Reset error count on success
            } catch (error) {
                console.error(`Error with ${currentModel} (Attempt ${attempts}):`, error);
                consecutiveErrors++;
                const isQuota = error.message.includes('429') || /quota|resource/i.test(error.message);
                const shouldSwitch = isQuota || consecutiveErrors >= 2; // Switch model on quota error or 2 consecutive errors

                if (shouldSwitch && AVAILABLE_MODELS.length > 1) {
                    const oldModel = currentModel;
                    currentModelIndex = (currentModelIndex + 1) % AVAILABLE_MODELS.length;
                    const nextModel = AVAILABLE_MODELS[currentModelIndex];
                    console.warn(`Switching model due to errors/quota from ${oldModel} to ${nextModel}.`);
                    showError(`Sparkle issue with ${oldModel}... Trying ${nextModel}! (Attempt ${attempts + 1})`);
                    consecutiveErrors = 0; // Reset counter after switching
                } else if (attempts < maxAttempts) {
                    showError(`Temporary hiccup with ${currentModel}... Retrying! (Attempt ${attempts + 1})`);
                }

                // Optional: Add a small delay before retrying
                if (!success && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 750));
                }
            }
        }

        if (!success) {
            console.error(`Failed after ${maxAttempts} attempts.`);
            showError(`Oh no! Failed to get a response after ${maxAttempts} tries! Check your API key, connection, or try again later? T_T`);
            // Maybe revert to the last known good HTML state? Or show a specific error message in turn-content?
            turnContentContainer.innerHTML = `<div class="kawaii-card error-message">Could not load the next part of the adventure after multiple tries. Please check your connection or API key and try resetting or reloading.</div>`;
        } else {
            hideError(); // Clear any temporary error messages
            window.scrollTo({ top: 0, behavior: 'smooth' }); // Scroll to top on success
        }

        setLoading(false); // Ensure loading is stopped regardless of outcome
    }

    // JS Change: Modified API call to specify response MIME type if needed, handle plain text response
    async function callRealGeminiAPI(apiKey, promptText, modelName, responseMimeType = "text/plain") { // Default to text/plain
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
        const requestBody = {
            contents: [{ parts: [{ text: promptText }] }],
            generationConfig: {
                temperature: 1.0, // Keep creativity high
                // JS Change: Explicitly ask for plain text, as we'll treat it as HTML
                response_mime_type: responseMimeType
            },
            // Keep safety settings permissive as before
            safetySettings: [
                {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
            ]
        };

        console.log("Sending API request to:", API_URL);
        // console.log("Request body:", JSON.stringify(requestBody)); // Be careful logging prompts with sensitive info

        const response = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            let errorBodyText = `API Error (${response.status})`;
            try {
                const errorJson = await response.json();
                errorBodyText += `: ${JSON.stringify(errorJson.error)}`;
            } catch (e) {
                try {
                    // Fallback if response is not JSON
                    errorBodyText += `: ${await response.text()}`;
                } catch (e2) { /* Ignore further errors */ }
            }
            throw new Error(errorBodyText);
        }

        const data = await response.json();

        // Check for prompt feedback issues (blocking)
        if (data.promptFeedback?.blockReason) {
            throw new Error(`Request blocked by API. Reason: ${data.promptFeedback.blockReason}. Ratings: ${JSON.stringify(data.promptFeedback.safetyRatings)}`);
        }

        // Check if candidates exist
        if (!data.candidates?.length) {
            // Sometimes the response might be directly in the data if not blocked? Check this.
            if (typeof data === 'string') return data.trim(); // Highly unlikely based on Gemini API structure
            throw new Error('API returned successfully but generated no candidates.');
        }

        const candidate = data.candidates[0];

        // Check for finish reason issues (other than normal stop)
        if (candidate.finishReason && !["STOP", "MAX_TOKENS"].includes(candidate.finishReason)) {
            const reason = `API Finish Reason: ${candidate.finishReason}. Safety Ratings: ${JSON.stringify(candidate.safetyRatings)}`;
            if (!candidate.content?.parts?.length) {
                throw new Error(reason + " (No content returned)");
            }
            // Log warning if finished abnormally but still provided content
            console.warn(reason + " (Partial content might have been returned)");
        }

        // Check if content parts exist
        if (!candidate.content?.parts?.length) {
            throw new Error('API candidate generated but no content parts found.');
        }

        // Extract the text content (which should be our HTML)
        const htmlContent = candidate.content.parts[0].text;
        if (!htmlContent) {
            throw new Error('API returned empty content part.');
        }

        // Basic validation: Does it look like HTML? (Very basic check)
        const trimmedContent = htmlContent.trim();
        if (!trimmedContent.startsWith('<') || !trimmedContent.endsWith('>')) {
            console.warn(`API response might not be valid HTML. Snippet: ${trimmedContent.substring(0, 100)}...`);
            // Decide whether to throw an error or try rendering anyway
            // For now, let's try rendering it.
        }

        return trimmedContent; // Return the raw HTML string
    }


    /** Displays an error message. */
    function showError(message) { /* ... (no changes needed) ... */
        errorDisplay.textContent = message;
        errorDisplay.style.display = 'block';
    }

    /** Hides the error message. */
    function hideError() { /* ... (no changes needed) ... */
        errorDisplay.textContent = '';
        errorDisplay.style.display = 'none';
    }

    // JS Change: Updated collectInputState to use FormData
    function collectInputState() {
        const form = turnContentContainer.querySelector('#kawaii-turn-form');
        if (!form) {
            console.warn("Could not find #kawaii-turn-form to collect input.");
            // Return minimal state if form is missing (e.g., after an error)
            return JSON.stringify({
                turn: currentTurnNumber,
                subjectId: currentSubjectId
                // No actions available
            });
        }

        const formData = new FormData(form);
        const inputs = {};
        // Convert FormData to a simple key-value object
        for (const [key, value] of formData.entries()) {
            // Handle potential multiple values for checkboxes if needed,
            // but typically radios/sliders/text override simply.
            inputs[key] = value;
        }

        console.log("Collected form data:", inputs);

        // Ensure essential hidden fields are included, even if somehow missing from form
        // (though the LLM should always include them)
        if (!inputs.hasOwnProperty('turn')) inputs.turn = currentTurnNumber;
        if (!inputs.hasOwnProperty('subjectId')) inputs.subjectId = currentSubjectId;
        // We don't need to send back the internalState *from the form*,
        // we send the `currentInternalStateMarkdown` variable captured during response processing.

        return JSON.stringify(inputs);
    }

    // JS Change: Removed renderDashboard and all specific render functions
    // (renderStatusDisplay, renderEventDescription, renderImages, renderPlayerChoices,
    // renderSingleChoiceElement, renderText, renderTextField, renderCheckbox, renderSlider, renderRadio)
    // as the LLM now handles HTML generation.

    // --- Utility Functions ---
    function isValidHexColor(hex) { /* ... (no changes needed) ... */ return typeof hex === 'string' && /^#[0-9A-F]{6}$/i.test(hex); }
    function adjustColorForContrast(hex) { /* ... (no changes needed) ... */ if (!isValidHexColor(hex)) return hex; let r=parseInt(hex.substring(1,3),16)/255, g=parseInt(hex.substring(3,5),16)/255, b=parseInt(hex.substring(5,7),16)/255; const lum=0.2126*r+0.7152*g+0.0722*b; const MAX_LUM=0.6; if(lum>MAX_LUM){ const factor=MAX_LUM/lum; r=Math.max(0,r*factor); g=Math.max(0,g*factor); b=Math.max(0,b*factor); const toHex=x=>Math.round(x*255).toString(16).padStart(2,'0'); return `#${toHex(r)}${toHex(g)}${toHex(b)}`; } return hex; }
    function showClipboardMessage(message, isError = false) { /* ... (no changes needed) ... */ clipboardMessage.textContent = message; clipboardMessage.style.color = isError ? '#be123c' : '#059669'; setTimeout(() => { clipboardMessage.textContent = ''; }, 3000); }
    function updateModeButtonVisuals() { /* ... (no changes needed) ... */ if (isPassionateMode) { modeToggleButton.textContent = 'Mode: Passionate Embrace 🔥'; modeToggleButton.classList.remove('standard-mode'); } else { modeToggleButton.textContent = 'Mode: Sweet Cuddles 🍬'; modeToggleButton.classList.add('standard-mode'); } }
    function setDynamicImages() { /* ... (no changes needed, maybe update prompt if desired) ... */ const seed = Math.floor(Math.random() * 65536); const p = "wide panoramic cute kawaii landscape pastel colors sparkling rainbow giant friendly flowers anime style"; if (headerBanner) { headerBanner.src = `https://image.pollinations.ai/prompt/${encodeURIComponent(p)}?width=1200&height=120&seed=${seed}&nologo=true&safe=false`; headerBanner.alt = "Kawaii Adventure Banner"; } }

    // JS Change: Updated setLoading to disable form elements inside #turn-content
    function setLoading(loading) {
        isLoading = loading;
        loadingIndicator.style.display = loading ? 'flex' : 'none';
        const keyEntered = apiKeyInput.value.trim().length > 0;

        // Disable global controls
        submitButton.disabled = loading || !(apiKeyLocked || keyEntered);
        saveGameButton.disabled = loading || !apiKeyLocked;
        modeToggleButton.disabled = loading;
        resetGameButton.disabled = loading || !apiKeyLocked;
        apiKeyInput.disabled = loading || apiKeyLocked; // Disable API key input when loading or locked

        // Disable form elements within the dynamic content area
        const form = turnContentContainer.querySelector('#kawaii-turn-form');
        if (form) {
            form.style.opacity = loading ? 0.6 : 1.0;
            form.style.pointerEvents = loading ? 'none' : 'auto';
            form.querySelectorAll('input, textarea, button, select, fieldset').forEach(el => {
                el.disabled = loading;
            });
        }
    }


    // --- Initial Game Setup ---
    // JS Change: Updated initializeGame for HTML state restoration
    function initializeGame() {
        console.log("Initializing Kawaii Heart Adventures Deluxe (HTML Mode)...");
        let autoStarted = false;
        const storedStateString = localStorage.getItem(LOCAL_STORAGE_KEY);

        if (storedStateString) {
            console.log("Found saved diary (HTML).");
            let savedState;
            try {
                savedState = JSON.parse(storedStateString);
                const decodedApiKey = decodeApiKey(savedState.encodedApiKey);
                if (!decodedApiKey) throw new Error("Failed to decode API key from saved state.");

                apiKeyInput.value = decodedApiKey;
                currentTurnHTML = savedState.currentTurnHTML || null; // Restore HTML
                currentInternalStateMarkdown = savedState.currentInternalStateMarkdown || "";
                currentTurnNumber = savedState.currentTurnNumber || 0;
                currentSubjectId = savedState.currentSubjectId || "Cutie";
                isPassionateMode = savedState.isPassionateMode === true;
                currentModelIndex = savedState.currentModelIndex || 0;

                if (currentTurnHTML && currentTurnNumber > 0) {
                    apiKeyLocked = true;
                    autoStarted = true;
                    console.log(`Diary restored. Mode: ${isPassionateMode ? 'Passionate' : 'Sweet'}, Turn: ${currentTurnNumber}`);

                    // Render the restored HTML
                    turnContentContainer.innerHTML = currentTurnHTML;
                    // Execute any inline scripts from the restored HTML
                    const scripts = turnContentContainer.querySelectorAll('script');
                    scripts.forEach(script => { try { const newScript = document.createElement('script'); if(script.src){ newScript.src = script.src; } else { newScript.textContent = script.textContent; } script.parentNode.replaceChild(newScript, script); console.log("Executed inline script from restored HTML."); } catch(e){ console.error("Error executing restored script:", e); }});


                    apiKeySection.style.display = 'none'; // Hide API key section
                    submitButton.textContent = `Submit Turn ${currentTurnNumber + 1}`;
                    submitButton.disabled = false;
                    saveGameButton.disabled = false;
                    resetGameButton.disabled = false;
                    updateModeButtonVisuals();
                    setDynamicImages(); // Set header, etc.
                    hideError();
                    setLoading(false);
                } else {
                    // Saved state is incomplete or represents the initial state before first turn
                    console.warn("Restored state is incomplete or initial. Starting fresh.");
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    // Keep API key if present, but reset other state
                    currentTurnHTML = null;
                    currentInternalStateMarkdown = "";
                    currentTurnNumber = 0;
                    isPassionateMode = false;
                    apiKeyLocked = false;
                    autoStarted = false; // Force manual start or URL key check
                    resetManualStartUI(); // Show initial message
                }

            } catch (e) {
                console.error("Restore error (HTML):", e);
                showError(`Diary restore error: ${e.message}. Please start manually!`);
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                currentTurnHTML = null; currentInternalStateMarkdown = ""; currentTurnNumber = 0; isPassionateMode = false; currentModelIndex = 0; apiKeyLocked = false; autoStarted = false;
                apiKeyInput.value = ''; // Clear potentially bad key
                resetManualStartUI();
            }
        }

        // Check for API key in URL if not auto-started from localStorage
        if (!autoStarted) {
            try {
                const params = new URLSearchParams(window.location.search);
                const keyFromUrl = params.get('apiKey');
                if (keyFromUrl) {
                    console.log("API Key found in URL.");
                    apiKeyInput.value = keyFromUrl;
                    apiKeyLocked = false; // Will be locked on first successful response
                    currentTurnHTML = null; currentInternalStateMarkdown = ""; currentTurnNumber = 0; isPassionateMode = false; currentModelIndex = 0;

                    apiKeySection.style.display = 'none'; // Hide section since key is provided

                    // Clean the URL
                    const url = new URL(window.location.href);
                    url.searchParams.delete('apiKey');
                    window.history.replaceState(null, '', url.toString());

                    setDynamicImages();
                    updateModeButtonVisuals();
                    // Fetch the very first turn (Turn 0 -> generates Turn 1 HTML)
                    fetchTurnData(null); // Pass null actions for the first turn
                    autoStarted = true;
                    setLoading(true); // Show loading indicator
                    // Buttons will be enabled by processSuccessfulResponse
                    submitButton.textContent = "Loading Adventure...";
                    submitButton.disabled = true;
                    saveGameButton.disabled = true;
                    resetGameButton.disabled = true;
                    modeToggleButton.disabled = true;
                }
            } catch (e) {
                console.error("URL Parameter processing error:", e);
                showError("Error reading URL parameters. Please start manually!");
                autoStarted = false; // Ensure manual start UI is shown
            }
        }

        // Fallback to manual start UI if not started by localStorage or URL key
        if (!autoStarted) {
            console.log("Manual start required.");
            currentTurnHTML = null; currentInternalStateMarkdown = ""; currentTurnNumber = 0; isPassionateMode = false; currentModelIndex = 0; apiKeyLocked = false;
            // Don't clear API key input if user might have typed something
            resetManualStartUI();
        }
    }

    // JS Change: Updated reset function
    function resetManualStartUI() {
        turnContentContainer.innerHTML = ''; // Clear dynamic content
        hideError();

        // Re-create and show the initial message inside the turn container
        const initialMsgDiv = createInitialMessageDiv();
        initialMsgDiv.style.display = 'block';
        initialMsgDiv.innerHTML = 'Enter API Key & click "Start Adventure!"<br>Or paste saved code into console~';
        turnContentContainer.appendChild(initialMsgDiv); // Add message to the turn container

        if (apiKeySection) apiKeySection.style.display = 'block'; // Show API key input
        apiKeyInput.disabled = false; // Ensure API key input is enabled

        // Reset button states
        submitButton.textContent = 'Start Adventure!';
        submitButton.disabled = apiKeyInput.value.trim().length === 0; // Enable only if key is present
        saveGameButton.disabled = true;
        resetGameButton.disabled = apiKeyInput.value.trim().length === 0; // Allow reset if key is present but not started
        modeToggleButton.disabled = false; // Mode can be toggled before start

        setLoading(false);
        updateModeButtonVisuals();
        setDynamicImages(); // Reset header image etc.
    }

    // JS Change: Updated to create message within turn container if needed
    function createInitialMessageDiv() {
        let msgDiv = document.getElementById('initial-message');
        if (!msgDiv) {
            msgDiv = document.createElement('div');
            msgDiv.id = 'initial-message';
            // Add styling consistent with kawaii-card or similar
            msgDiv.className = 'text-center text-pink-500 p-4 font-semibold kawaii-card';
            // Prepending might be better if turn-content could have other static elements,
            // but appending is fine if it's meant to be the only content initially.
            // turnContentContainer.prepend(msgDiv);
        }
        return msgDiv;
    }

    // --- Event Listeners ---

    // JS Change: Use event delegation for the submit button
    gameContainer.addEventListener('click', (event) => {
        // Check if the clicked element is the submit button OR is inside the submit button
        const targetButton = event.target.closest('#submit-turn-button');
        if (targetButton && !targetButton.disabled) {
            console.log("Submit button clicked via delegation.");
            initAudioContext(); // Initialize audio on user interaction
            const actions = collectInputState(); // Collect data from the current form
            if (isLoading) return;
            fetchTurnData(actions); // Fetch next turn using collected actions
        }
    });

    apiKeyInput.addEventListener('input', () => { /* ... (no changes needed, logic remains the same) ... */
        const keyEntered = apiKeyInput.value.trim().length > 0;
        // Enable submit only if a key is entered AND the game isn't already locked/started
        submitButton.disabled = isLoading || !(keyEntered || apiKeyLocked);
        // Allow reset if key is entered, even if not locked yet
        resetGameButton.disabled = isLoading || !keyEntered;

        // Update initial message if visible
        if (apiKeySection.style.display !== 'none') {
            const msg = document.getElementById('initial-message');
            if (msg && msg.style.display !== 'none') {
                if (keyEntered) {
                    hideError();
                    msg.textContent = 'API Key ready! Click "Start Adventure!"';
                } else {
                    msg.innerHTML = 'Enter API Key & click "Start Adventure!"<br>Or paste saved code into console~';
                }
            }
        }
    });

    saveGameButton.addEventListener('click', () => { /* ... (no changes needed) ... */
        console.log("Save clicked.");
        saveGameState(false);
    });

    modeToggleButton.addEventListener('click', () => { /* ... (no changes needed, triggers save) ... */
        if (isLoading) return;
        isPassionateMode = !isPassionateMode;
        console.log(`Mode toggled to: ${isPassionateMode ? 'Passionate Embrace' : 'Sweet Cuddles'}`);
        updateModeButtonVisuals();
        // Auto-save state when mode changes, only if game has started
        if (apiKeyLocked) {
            saveGameState(true);
            // Optional: Immediately fetch a new turn reflecting the mode change?
            // This could be disruptive if the player didn't intend to change the current scene yet.
            // For now, the mode change will apply on the *next* turn submission.
            // To apply immediately:
            // const actions = collectInputState(); // Get current state actions *before* mode change applied visually
            // fetchTurnData(actions); // Fetch immediately
        }
    });

    resetGameButton.addEventListener('click', () => { /* ... (no changes needed, uses resetManualStartUI) ... */
        if (isLoading || resetGameButton.disabled) return;
        if (confirm('End this adorable adventure? All progress will be lost! T_T')) {
            console.log("Resetting game...");
            currentTurnHTML = null; currentInternalStateMarkdown = ""; currentSubjectId = "Cutie"; currentTurnNumber = 0; isPassionateMode = false; currentModelIndex = 0; apiKeyLocked = false;
            localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear saved state
            // Don't clear API key input, user might want to restart with the same key
            resetManualStartUI(); // Reset UI to initial state
        }
    });

    // --- Initialize ---
    initializeGame();

</script>

</body>
</html>
