<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GEEMS - LLM UI Remake</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    <style>
        /* Adapted CSS from styles.css & Tailwind Integration */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%); /* Light gray gradient */
            color: #1f2937; /* Dark gray text */
            margin: 0;
            padding: 0;
            padding-bottom: 180px; /* Ensure space for footer */
            min-height: 100vh;
        }

        /* Header Styling */
        .site-header {
            padding: 0;
            margin-bottom: 1.5rem; /* Reduced margin */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            text-align: center;
            position: relative;
            overflow: hidden;
            background-color: #374151; /* Darker header background */
        }

        .header-banner-image {
            width: 100%;
            height: 150px; /* Adjusted height */
            object-fit: cover;
            display: block;
            opacity: 0.5; /* Adjust opacity */
            filter: grayscale(50%) contrast(110%); /* Example filter */
        }

        .site-header h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem; /* Adjusted size */
            color: white;
            text-shadow: 1px 1px 6px rgba(0, 0, 0, 0.7);
            margin: 0;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            padding: 0 1rem;
            box-sizing: border-box;
            background: rgba(0, 0, 0, 0.5); /* Slightly darker title background */
            padding-top: 0.4rem;
            padding-bottom: 0.4rem;
        }

        /* Main Game Container */
        #game-container {
            background-color: white;
            border-radius: 0.75rem; /* 12px */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1.5rem; /* 24px */
            margin-top: 1rem;
            min-height: 300px; /* Ensure it has some height initially */
        }

        /* Container for LLM generated turn content */
        #turn-content {
            /* Add styles if needed, e.g., for transitions */
            transition: opacity 0.3s ease-in-out;
        }

        /* Footer Styling */
        .site-footer {
            margin-top: 2rem;
            padding: 1.5rem 1rem;
            text-align: center;
            font-size: 0.875rem; /* 14px */
            color: #4b5563; /* Medium gray text */
            border-top: 1px solid #d1d5db; /* Light gray border */
            background-color: #f9fafb; /* Very light gray background */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 10;
        }

        .footer-buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 0.5rem; /* Reduced margin */
        }

        #clipboardMessage {
            font-size: 0.8rem;
            color: #16a34a; /* Default success color */
            height: 1.2em;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        /* General styles for elements potentially generated by LLM */
        /* These act as defaults if the LLM doesn't provide specific Tailwind classes */
        .geems-panel {
            margin-bottom: 1.5rem;
            padding: 1.25rem;
            background-color: #f9fafb; /* Light background for panels */
            border-radius: 0.5rem; /* 8px */
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        .geems-panel h3 { /* Style for panel titles */
            font-family: 'Playfair Display', serif;
            font-size: 1.25rem; /* 20px */
            font-weight: 700;
            color: #4f46e5; /* Indigo */
            border-bottom: 2px solid #a5b4fc; /* Lighter indigo border */
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }

        .geems-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #4f46e5; /* Indigo */
            font-size: 0.9rem;
        }

        .geems-text {
            color: #374151; /* Darker gray text */
            line-height: 1.6;
            word-wrap: break-word;
            font-size: 1rem;
        }
        .geems-text strong { color: #7c3aed; /* Violet */ }
        .geems-text em { color: #db2777; /* Pink */ font-style: italic; }
        .geems-text pre {
            background-color: #1f2937;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            color: #d1d5db;
            margin-top: 0.75rem;
            border: 1px solid #374151;
        }

        /* Input and Textarea styles */
        .geems-input, .geems-textarea {
            width: 100%;
            padding: 0.8rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem; /* 6px */
            box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            color: #1f2937;
            background-color: #fff;
            transition: border-color 0.2s, box-shadow 0.2s;
            box-sizing: border-box;
        }
        .geems-input::placeholder, .geems-textarea::placeholder { color: #9ca3af; }
        .geems-input:focus, .geems-textarea:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }
        .geems-textarea { min-height: 80px; }

        /* Radio and Checkbox option styling */
        .geems-radio-option, .geems-checkbox-option {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            padding: 0.7rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 1px solid #e5e7eb;
        }
        .geems-radio-option:hover, .geems-checkbox-option:hover { background-color: #f0f9ff; }
        .geems-radio-option input[type="radio"], .geems-checkbox-option input[type="checkbox"] {
            margin-right: 0.75rem;
            cursor: pointer;
            accent-color: #6366f1;
            width: 1rem; height: 1rem;
        }
        .geems-radio-option label, .geems-checkbox-option label {
            color: inherit; flex-grow: 1; cursor: pointer;
        }

        /* Slider styling */
        .geems-slider {
            width: 100%; cursor: pointer; accent-color: #6366f1; height: 0.5rem;
            background: #e5e7eb; border-radius: 9999px; appearance: none; -webkit-appearance: none;
        }
        .geems-slider::-webkit-slider-thumb {
            appearance: none; -webkit-appearance: none; width: 1.1rem; height: 1.1rem;
            background: var(--slider-thumb-color, #4f46e5); border-radius: 50%; cursor: pointer;
        }
        .geems-slider::-moz-range-thumb {
            width: 1.1rem; height: 1.1rem; background: var(--slider-thumb-color, #4f46e5);
            border-radius: 50%; cursor: pointer; border: none;
        }
        .geems-slider-value-display { color: #4f46e5; font-weight: 500; min-width: 2rem; text-align: right; }

        /* Image container and styling */
        .geems-image-container { text-align: center; margin-bottom: 1rem; }
        .geems-image {
            max-width: 100%; height: auto; border-radius: 0.5rem; margin-bottom: 0.5rem;
            background-color: #e5e7eb; display: block; margin-left: auto; margin-right: auto;
            border: 1px solid #d1d5db;
        }
        .geems-image-prompt {
            font-size: 0.75rem; color: #6b7280; font-style: italic; margin-top: 0.25rem;
            word-wrap: break-word; padding: 0 0.5rem;
        }

        /* Button styling */
        .geems-button {
            padding: 0.75rem 1.75rem; /* Adjusted padding */
            background: linear-gradient(to right, #4f46e5, #7c3aed);
            color: white; border: none; border-radius: 0.375rem; /* 6px */
            font-weight: 600; cursor: pointer; transition: all 0.2s ease;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            text-transform: uppercase; letter-spacing: 0.05em; white-space: nowrap;
            font-size: 0.875rem; /* 14px */
        }
        .geems-button:hover {
            background: linear-gradient(to right, #4338ca, #6d28d9);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transform: translateY(-1px);
        }
        .geems-button:active { transform: translateY(0); box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
        .geems-button:disabled {
            background: #a5b4fc; cursor: not-allowed; opacity: 0.7; box-shadow: none; transform: none;
        }

        /* Loading and Error message styling */
        .loading-indicator, .error-message {
            display: flex; justify-content: center; align-items: center;
            padding: 1.5rem; font-size: 1rem; border-radius: 0.5rem; margin-top: 1rem;
        }
        .loading-indicator { color: #4f46e5; background-color: #e0e7ff; border: 1px solid #c7d2fe; }
        .loading-indicator svg { width: 1.25rem; height: 1.25rem; }
        .error-message { color: #991b1b; background-color: #fef2f2; border: 1px solid #fecaca; text-align: center; white-space: pre-wrap; font-weight: 500; }

        /* API Key Input Section */
        #apiKeySection {
            margin-bottom: 1.5rem; background: white; padding: 1.25rem; border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border-left: 4px solid #fbbf24; /* Amber border */
        }
        #apiKeySection .geems-label { color: #d97706; /* Darker amber */ }
        #apiKeySection .api-key-instructions a { color: #4f46e5; text-decoration: underline; }
        #apiKeySection .api-key-instructions a:hover { color: #3730a3; }

        /* Grid layout for panels (Example - LLM can use this or define its own structure) */
        .panel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Responsive grid */
            gap: 1.5rem;
        }

        /* Specific panel styling examples (LLM can apply these classes) */
        .image-panel { /* Example */
            /* Styles specific to image panel */
        }
        .story-panel { /* Example */
            /* Styles specific to story panel */
        }
        .choices-panel { /* Example */
            /* Styles specific to choices panel */
        }
        .status-panel { /* Example */
            /* Styles specific to status panel */
        }

    </style>
</head>
<body class="bg-gray-100 font-inter">

<header class="site-header">
    <img id="headerBanner" alt="GEEMS Header Banner" class="header-banner-image" src="https://placehold.co/1200x150/374151/e5e7eb?text=Loading+Banner...">
    <h1>GEEMS - LLM UI</h1>
</header>

<div class="max-w-5xl mx-auto px-4 md:px-8 py-6">

    <div id="apiKeySection">
        <label for="apiKeyInput" class="geems-label api-key-instructions">
            Enter Google AI API Key to Begin Your Session:
            <span class="block text-sm font-normal text-gray-600 mt-1">
                    (Get a key from Google AI Studio:
                    <a href="https://aistudio.google.com/apikey" target="_blank" rel="noopener noreferrer" class="hover:text-indigo-700">
                        aistudio.google.com/apikey
                    </a>)
                    <br>Or provide via URL parameter: ?apiKey=YOUR_API_KEY
                </span>
        </label>
        <input type="password" id="apiKeyInput" class="geems-input mt-2" placeholder="Paste your secure API key here...">
    </div>

    <div id="game-container">
        <div id="turn-content">
            <div id="initial-message" class="text-center text-gray-500 p-6">
                Enter your API Key above and click "Start Session / Next Turn" to begin.
            </div>
        </div>
    </div>

    <div id="loading" class="loading-indicator" style="display: none;">
        <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        Processing... Please wait.
    </div>

    <div id="error-display" class="error-message" style="display: none;"></div>

    <div class="mt-6 text-center">
        <button id="next-turn-button" class="geems-button" disabled>
            Start Session / Next Turn
        </button>
    </div>

</div>

<footer class="site-footer">
    <div class="footer-buttons">
        <button id="resetGameButton" class="geems-button" disabled>Reset Session</button>
    </div>
    <div id="clipboardMessage"></div>
    <div class="footer-content">
        <span>GEEMS LLM UI Version &copy; 2025</span>
    </div>
</footer>

<script type="module">
    // --- Game State Variables ---
    let historyQueue = []; // Stores { turnHTML: "...", playerActions: {...} }
    const MAX_HISTORY_SIZE = 10; // Keep history manageable
    let currentTurnHTML = null; // Stores the HTML of the current turn
    let currentTurnNumber = 0;
    let currentSubjectId = "SubjectZero"; // Default subject ID
    let currentNotes = ""; // Stores the 'notes' content from hidden input
    let isLoading = false;
    let apiKeyLocked = false;

    // --- Model Switching State ---
    const AVAILABLE_MODELS = ["gemini-2.5-pro-exp-03-25", "gemini-1.5-pro", "gemini-2.0-pro-exp-02-05", "gemini-2.0-flash-exp", "gemini-exp-1206"];
    let currentModelIndex = 0;

    // --- Configuration ---
    const LOCAL_STORAGE_KEY = 'geemsLlmUiState_v1';
    const POLLINATIONS_URL_BASE = "https://image.pollinations.ai/prompt/";

    // --- DOM Element References ---
    const turnContentContainer = document.getElementById('turn-content');
    const loadingIndicator = document.getElementById('loading');
    const nextTurnButton = document.getElementById('next-turn-button');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const apiKeySection = document.getElementById('apiKeySection');
    const errorDisplay = document.getElementById('error-display');
    const resetGameButton = document.getElementById('resetGameButton');
    const clipboardMessage = document.getElementById('clipboardMessage');
    const headerBanner = document.getElementById('headerBanner');
    const gameContainer = document.getElementById('game-container'); // Main container for event delegation

    // --- Prompts (Adapted from prompts.js) ---
    const geemsLlmUiPrompts = {
        // Note: Masturbation mode addendum removed as per focus change,
        // but could be added back if desired.

        firstrun: `**Instructions for Generating Turn 1 HTML UI ONLY:**

**(Input: None. Output: Raw HTML snippet for the Turn 1 UI within #turn-content)**

* **Goal:** Generate the initial HTML UI for the \`#turn-content\` div. Introduce a **random, engaging scenario** (e.g., bustling futuristic market, serene alien garden, strange laboratory). Present it with an initial aesthetic that is **visually interesting and hints at the game's potential for exploration and interaction.** The UI should include distinct panels for different types of content (story, image, choices). Establish the baseline for player interaction.
* **HTML Structure:**
    * Generate HTML content meant to be placed inside the \`<div id="turn-content">\`.
    * Use Tailwind CSS classes extensively for styling. You can also use the provided \`.geems-panel\`, \`.geems-label\`, \`.geems-text\`, \`.geems-image\`, etc., classes as defaults or fallbacks.
    * **Panel Structure:** Create distinct sections/panels using \`<div>\` elements. Assign appropriate classes (e.g., \`class="geems-panel image-panel"\`, \`class="geems-panel story-panel"\`, \`class="geems-panel choices-panel"\`). You can use a grid layout (e.g., \`<div class="panel-grid">\`) or flexbox to arrange them.
    * **Story Panel:** Include a title (\`<h3>\` or similar) and descriptive text (\`<p class="geems-text">\`) introducing the scenario.
    * **Image Panel:** Generate 1-2 images using \`<img>\` tags.
        * **CRITICAL:** Use the Pollinations.ai URL format: \`${POLLINATIONS_URL_BASE}{GENERATED_PROMPT}?width={WIDTH}&height={HEIGHT}&seed={RANDOM_SEED}&nologo=true&safe=false\`.
        * Generate relevant \`{GENERATED_PROMPT}\` text matching the scene.
        * Choose appropriate \`{WIDTH}\` and \`{HEIGHT}\` (e.g., 400x300). Use a random \`{RANDOM_SEED}\`.
        * Include a \`<p class="geems-image-prompt">\` below each image showing the prompt used.
        * Add \`onerror="this.src='https://placehold.co/{W}x{H}/e0e7ff/4f46e5?text=Image+Error'; this.alt='Error Loading Image'"\` to each image tag, replacing {W} and {H}.
    * **Choices Panel:** Wrap choices in \`<form id="geems-turn-form">\`. Include initial actions using radio buttons (\`<input type="radio">\`) or other simple inputs. Provide clear labels (\`<label>\`).
    * **Hidden Fields:** CRITICAL - Include hidden inputs within the form:
        * \`<input type='hidden' name='turn' value='1'>\`
        * \`<input type='hidden' name='subjectId' value='SubjectOne'>\` (or similar initial ID)
        * \`<input type='hidden' name='notes' value='INITIAL_STATE_MARKDOWN'>\` (See below)
    * **Panel Refresh Metadata (Optional but Recommended):** For elements intended to trigger panel refreshes (like radio buttons), add data attributes:
        * \`data-trigger-action="refreshPanel"\`
        * \`data-target-panels="#image-panel,#story-panel"\` (CSS selectors for panels to update)
        * \`data-input-name="main_action"\` (Name of the input providing the value)
* **Initial Notes Markdown:** The \`notes\` hidden field should contain initial JSON-escaped Markdown:
    \`"# Game State - Turn 1\\n\\n**Player Profile:**\\n* Subject ID: SubjectOne\\n\\n**Narrative State:**\\n* Location: [Generated Location Name]\\n* Last Event: Session Start\\n* World Modifiers: ['Initial']\\n\\n**Internal Log:**\\n* Plan: Introduce scenario and initial choices."\`
* **No Submit Button:** DO NOT include the main \`#next-turn-button\` within the generated HTML. It exists outside this container.
* **Output:** Raw HTML snippet ready for injection into \`#turn-content\`.

* **Example Output Snippet Start:**
    \`\`\`html
    <div class="panel-grid">
      <div class="geems-panel story-panel" id="story-panel">
        <h3>Arrival at Neo-Kyoto Market</h3>
        <p class="geems-text">Rain slicks the neon-lit streets of the Neo-Kyoto market district. Holographic koi fish swim through the air above crowded stalls selling everything from synthetic noodles to black market cybernetics. The air hums with energy and the smell of ozone.</p>
      </div>

      <div class="geems-panel image-panel" id="image-panel">
        <h3>Market View</h3>
        <img src="${POLLINATIONS_URL_BASE}Neo-Kyoto%20market%20street%20at%20night%2C%20raining%2C%20neon%20signs%2C%20holographic%20koi%20fish%2C%20cyberpunk%20aesthetic?width=400&height=300&seed=12345&nologo=true&safe=false"
             alt="Neo-Kyoto market street at night"
             class="geems-image"
             onerror="this.src='https://placehold.co/400x300/e0e7ff/4f46e5?text=Image+Error'; this.alt='Error Loading Image'">
        <p class="geems-image-prompt">Neo-Kyoto market street at night, raining, neon signs, holographic koi fish, cyberpunk aesthetic</p>
      </div>

      <div class="geems-panel choices-panel" id="choices-panel">
        <h3>First Steps</h3>
        <form id="geems-turn-form">
          <input type='hidden' name='turn' value='1'>
          <input type='hidden' name='subjectId' value='SubjectOne'>
          <input type='hidden' name='notes' value='INITIAL_STATE_MARKDOWN_ESCAPED'>

          <label class="geems-label">What do you do first?</label>
          <div class="geems-radio-option">
            <input type="radio" id="action_explore" name="main_action" value="explore_market" checked
                   data-trigger-action="refreshPanel" data-target-panels="#story-panel,#image-panel,#choices-panel" data-input-name="main_action">
            <label for="action_explore">Explore the nearby stalls</label>
          </div>
          <div class="geems-radio-option">
            <input type="radio" id="action_shelter" name="main_action" value="find_shelter"
                   data-trigger-action="refreshPanel" data-target-panels="#story-panel,#image-panel,#choices-panel" data-input-name="main_action">
            <label for="action_shelter">Find shelter from the rain</label>
          </div>
           <div class="geems-radio-option">
            <input type="radio" id="action_observe" name="main_action" value="observe_crowd"
                   data-trigger-action="refreshPanel" data-target-panels="#story-panel,#image-panel,#choices-panel" data-input-name="main_action">
            <label for="action_observe">Observe the crowd</label>
          </div>
        </form>
      </div>
    </div>
    \`\`\`
    `,

        main: `**GEEMS LLM UI Turn Generation Protocol v1.0 - HTML Output**

**(Input: Player Actions JSON, Previous Notes Markdown String. Output: Raw HTML snippet for the next turn UI within #turn-content)**

**Core Goals:**
1.  **Generate Turn UI (HTML):** Generate the COMPLETE HTML content for the \`<div id="turn-content">\`. This HTML should represent the entire game state for the current turn, including narrative descriptions, images, interactive choices, status displays, etc., organized into logical panels.
2.  **Dynamic & Interactive:** The generated HTML should contain interactive elements (forms, inputs) that allow the player to make choices. Include metadata (\`data-*\` attributes) on interactive elements if they should trigger partial UI refreshes.
3.  **Stateful & Adaptive:** Use the provided \`notes\` Markdown string (which contains the game history, player profile, and internal state) to inform the generated narrative, choices, and visuals. Update the \`notes\` string based on player actions and return the *new* version in a hidden input field within the generated HTML.
4.  **Visual Storytelling:** Generate descriptive image prompts for the Pollinations.ai API (\`${POLLINATIONS_URL_BASE}{...}\`) and embed the resulting \`<img>\` tags within the HTML structure, placed logically within relevant panels.

**--- Protocol ---**

1.  **Analyze Input:** Parse the \`playerActionsJson\` (containing data from the previous turn's form) and the \`previousNotesMarkdown\`. Extract the player's choices, current turn number, subject ID, and the full internal state/history from the notes.
2.  **Update Notes & State:**
    * Increment the turn number.
    * Process the player's actions and update the game state *within the notes Markdown string*. This includes updating the narrative state (location, last event), player profile (if applicable), internal logs, etc.
    * Log the player's actions and the resulting state changes within the notes.
    * Plan the next event/scenario based on the updated state and player choices. Log this plan in the notes.
3.  **Generate Next Turn HTML (for \`#turn-content\`):**
    * **Structure:** Create a complete HTML snippet. Use \`<div>\` elements with appropriate classes (Tailwind CSS, \`.geems-panel\`, \`.panel-grid\`, panel-specific classes like \`.story-panel\`) to structure the content into logical panels (e.g., Story, Image(s), Choices, Status).
    * **Styling:** Use Tailwind CSS classes extensively (\`class="..."\`) for layout, colors, spacing, etc. Use \`.geems-*\` classes as fallbacks or for consistent styling.
    * **Narrative Panel:** Generate updated descriptive text (\`<p class="geems-text">\`) reflecting the outcome of the player's last action and introducing the new situation. Include a title (\`<h3>\`).
    * **Image Panel(s):** Generate 1-3 relevant images using \`<img>\` tags with the required \`${POLLINATIONS_URL_BASE}{...}\` format. Include descriptive \`alt\` text and the \`.geems-image-prompt\` paragraph below each. Add the \`onerror\` attribute for fallbacks.
    * **Choices Panel:** Create a \`<form id="geems-turn-form">\`. Include interactive elements (\`radio\`, \`checkbox\`, \`slider\`, \`textarea\`) for the player's next actions. Use clear labels (\`<label>\`).
        * **Panel Refresh Metadata:** Add \`data-trigger-action="refreshPanel"\`, \`data-target-panels="..."\`, and \`data-input-name="..."\` attributes to inputs that should trigger partial refreshes. The \`#next-turn-button\` handles full refreshes.
    * **Other Panels (Optional):** Include panels for status, inventory, character info, etc., as needed, generating the relevant HTML content.
    * **Hidden Fields:** CRITICAL - Include updated hidden fields inside the form:
        * \`<input type='hidden' name='turn' value='{new_turn_number}'>\`
        * \`<input type='hidden' name='subjectId' value='{current_subject_id}'>\`
        * \`<input type='hidden' name='notes' value='{UPDATED_escaped_markdown_state}'>\` (Return the fully updated notes string here).
    * **NO Submit Button:** Do NOT include the main \`#next-turn-button\` in this generated HTML.
4.  **Escape & Compile Output:** Ensure valid HTML. JSON-escape the updated notes string before putting it in the hidden input's value attribute. Return the complete raw HTML snippet for \`#turn-content\`.

**--- Input Example (What the LLM Receives) ---**
\`\`\`json
{
  "playerActionsJson": {
    "turn": 1,
    "subjectId": "SubjectOne",
    "main_action": "explore_market"
    // ... any other inputs from turn 1 form
  },
  "previousNotesMarkdown": "# Game State - Turn 1\\n\\n**Player Profile:**\\n* Subject ID: SubjectOne\\n\\n**Narrative State:**\\n* Location: Neo-Kyoto Market\\n* Last Event: Session Start\\n* World Modifiers: ['Initial']\\n\\n**Internal Log:**\\n* Plan: Introduce scenario and initial choices."
}
\`\`\`

**--- Output Example (What the LLM Generates - Turn 2 Snippet) ---**
\`\`\`html
<div class="panel-grid">
  <div class="geems-panel story-panel" id="story-panel">
    <h3>Exploring the Stalls</h3>
    <p class="geems-text">You push through the drizzle towards a stall flickering with a 'RAMEN' sign. Steam billows out, carrying the scent of synth-broth and something spicy. A gruff-looking vendor with cybernetic eyes watches you approach.</p>
  </div>

  <div class="geems-panel image-panel" id="image-panel">
    <h3>Ramen Stall</h3>
    <img src="${POLLINATIONS_URL_BASE}Cyberpunk%20ramen%20stall%20vendor%20with%20cybernetic%20eyes%20watching%20intently%2C%20steam%20rising%2C%20neon%20lighting?width=400&height=300&seed=67890&nologo=true&safe=false"
         alt="Cyberpunk ramen stall vendor"
         class="geems-image"
         onerror="this.src='https://placehold.co/400x300/e0e7ff/4f46e5?text=Image+Error'; this.alt='Error Loading Image'">
    <p class="geems-image-prompt">Cyberpunk ramen stall vendor with cybernetic eyes watching intently, steam rising, neon lighting</p>
  </div>

  <div class="geems-panel choices-panel" id="choices-panel">
    <h3>Interaction</h3>
    <form id="geems-turn-form">
      <input type='hidden' name='turn' value='2'>
      <input type='hidden' name='subjectId' value='SubjectOne'>
      <input type='hidden' name='notes' value='{UPDATED_NOTES_MARKDOWN_TURN_2_ESCAPED}'>

      <label class="geems-label">The vendor grunts, "Need somethin'?"</label>
      <div class="geems-radio-option">
        <input type="radio" id="action_order" name="vendor_interaction" value="order_ramen" checked
               data-trigger-action="refreshPanel" data-target-panels="#story-panel,#choices-panel" data-input-name="vendor_interaction">
        <label for="action_order">Order a bowl of ramen</label>
      </div>
      <div class="geems-radio-option">
        <input type="radio" id="action_ask" name="vendor_interaction" value="ask_info"
               data-trigger-action="refreshPanel" data-target-panels="#story-panel,#choices-panel" data-input-name="vendor_interaction">
        <label for="action_ask">Ask about the market</label>
      </div>
       <div class="geems-radio-option">
        <input type="radio" id="action_leave" name="vendor_interaction" value="leave_stall"
               data-trigger-action="refreshPanel" data-target-panels="#story-panel,#image-panel,#choices-panel" data-input-name="vendor_interaction">
        <label for="action_leave">Decide against it and walk away</label>
      </div>
    </form>
  </div>
</div>
\`\`\`

**--- Key Principles ---**
* **HTML Output:** Generate the *entire UI content* for the turn as a single HTML snippet.
* **State via Notes:** Use the \`notes\` Markdown string as the sole source and repository for game state, history, and internal LLM logs. Return the updated version in the hidden input.
* **Panel Structure:** Organize content logically using divs and classes (\`.geems-panel\`, \`.panel-grid\`, etc.).
* **Interactivity:** Use standard HTML forms and inputs for player choices. Use \`data-*\` attributes for optional panel refresh triggers.
* **Visuals:** Embed images using \`<img>\` tags and the specified \`${POLLINATIONS_URL_BASE}\` format.
* **Styling:** Rely on Tailwind CSS classes primarily.
`
    };

    // --- Web Audio API Context ---
    let audioCtx = null;

    // --- Helper Functions ---
    function encodeApiKey(key) { try { return btoa(key); } catch (e) { console.error("Error encoding API key:", e); return ""; } }
    function decodeApiKey(encodedKey) { try { return atob(encodedKey); } catch (e) { console.error("Error decoding API key:", e); return null; } }

    /** Constructs the full prompt for the Gemini API call. */
    function constructPrompt(playerActionsJson) {
        // Use the 'notes' field as the primary history/state log
        const historyString = currentNotes || "# Game State - Turn 0\n* Initializing session."; // Use currentNotes

        if (currentTurnNumber === 0) { // First run
            console.log("Constructing prompt for Turn 1 (HTML UI)");
            // Provide minimal context, rely on the 'firstrun' prompt structure
            const s = `${geemsLlmUiPrompts.firstrun}`;
            return s;
        } else { // Subsequent Turns
            console.log(`Constructing prompt for Turn ${currentTurnNumber + 1} (HTML UI)`);
            // Prepare the input object for the main prompt
            const promptInput = {
                playerActionsJson: playerActionsJson ? JSON.parse(playerActionsJson) : {}, // Parse actions
                previousNotesMarkdown: historyString // Pass the full notes log
            };
            const promptInputString = JSON.stringify(promptInput, null, 2);

            const s = `${geemsLlmUiPrompts.main}\n\n--- Input Context ---\n${promptInputString}\n\n--- Generate Next Game Turn RAW HTML UI SNIPPET (for #turn-content) ---`;
            return s;
        }
    }


    /** Saves the current essential game state to local storage. */
    function autoSaveGameState() {
        if (!apiKeyLocked) return;
        const rawApiKey = apiKeyInput.value.trim();
        if (!rawApiKey || !currentTurnHTML) return; // Need key and current UI to save meaningfully
        try {
            const stateToSave = {
                encodedApiKey: encodeApiKey(rawApiKey),
                currentTurnHTML: currentTurnHTML, // Save the rendered HTML
                currentNotes: currentNotes,       // Save the latest notes
                currentTurnNumber: currentTurnNumber,
                currentSubjectId: currentSubjectId,
                currentModelIndex: currentModelIndex
            };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(stateToSave));
            console.log("Game state auto-saved (HTML UI). Turn:", currentTurnNumber);
        } catch (error) {
            console.error("Error during auto-save:", error);
            showError("Error auto-saving game state.");
        }
    }

    /** Initializes the AudioContext if it doesn't exist. */
    function initAudioContext() {
        if (!audioCtx) {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                console.log("AudioContext initialized.");
                if (audioCtx.state === 'suspended') audioCtx.resume();
            } catch (e) { console.error("Web Audio API not supported.", e); }
        }
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume().catch(err => console.error("Error resuming audio context:", err));
        }
    }

    /** Plays the turn alert sound. */
    function playTurnSound() {
        initAudioContext();
        if (!audioCtx || audioCtx.state !== 'running') return;
        // Simple beep sound
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A5 note
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); // Low volume
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + 0.3);
        console.log("Playing turn sound.");
    }

    /** Processes the successful HTML response from the Gemini API. */
    function processSuccessfulResponse(responseHTML, playerActionsJson) {
        currentTurnHTML = responseHTML; // Store the raw HTML

        // Inject the HTML into the container
        turnContentContainer.innerHTML = responseHTML;
        console.log("Updated #turn-content with new HTML UI.");

        // Extract hidden state for the *next* request
        const form = turnContentContainer.querySelector('#geems-turn-form');
        if (form) {
            const turnInput = form.querySelector('input[name="turn"]');
            const subjectInput = form.querySelector('input[name="subjectId"]');
            const notesInput = form.querySelector('input[name="notes"]');

            // Update game state based on hidden inputs from the *newly rendered* UI
            currentTurnNumber = turnInput ? parseInt(turnInput.value, 10) : currentTurnNumber + 1;
            currentSubjectId = subjectInput ? subjectInput.value : currentSubjectId;
            currentNotes = notesInput ? notesInput.value : currentNotes; // Update notes from response

            console.log(`State Updated: Turn=${currentTurnNumber}, Subject=${currentSubjectId}, Notes Length=${currentNotes.length}`);

            // Re-attach event listeners for panel refreshes if needed (using delegation)
            attachPanelRefreshListeners();

        } else {
            console.warn("Could not find #geems-turn-form in the received HTML. State might be stale.");
            // Increment turn number anyway, but notes won't be updated from LLM
            currentTurnNumber++;
        }


        if (!apiKeyLocked) {
            apiKeyLocked = true;
            if (apiKeySection) apiKeySection.style.display = 'none';
            resetGameButton.disabled = false;
            console.log("API Key locked. Session active.");
        }

        nextTurnButton.textContent = `Next Turn (${currentTurnNumber})`;
        nextTurnButton.disabled = false;

        playTurnSound();
        autoSaveGameState(); // Save the new state including HTML and notes
    }


    /** Fetches the next turn's UI data from the Gemini API. */
    async function fetchTurnData(playerActionsJson, isPanelRefresh = false, targetPanelSelectors = null) {
        console.log(`fetchTurnData called. Turn: ${currentTurnNumber}, isPanelRefresh: ${isPanelRefresh}`);
        initAudioContext();
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
            showError("Please enter API Key");
            setLoading(false);
            if (apiKeySection && apiKeySection.style.display === 'none') apiKeySection.style.display = 'block';
            return;
        }

        setLoading(true, isPanelRefresh); // Indicate loading state
        hideError();
        const initialMsgEl = document.getElementById('initial-message');
        if (initialMsgEl) initialMsgEl.style.display = 'none';

        let success = false;
        let attempts = 0;
        const maxAttempts = AVAILABLE_MODELS.length * 2 + 1;
        let currentAttemptConsecutiveErrors = 0;

        // Construct the prompt - always use the main prompt logic now
        // The prompt needs the *latest* notes and the actions that triggered this call
        const fullPrompt = constructPrompt(playerActionsJson);

        while (!success && attempts < maxAttempts) {
            attempts++;
            const currentModel = AVAILABLE_MODELS[currentModelIndex];
            console.log(`Attempt ${attempts}/${maxAttempts}: Trying model ${currentModel}`);
            try {
                console.log(`Sending Prompt to ${currentModel} (requesting HTML)`);
                // Send the full prompt requesting the complete next state HTML
                const responseHTML = await callRealGeminiAPI(apiKey, fullPrompt, currentModel);
                console.log(`Received HTML response from ${currentModel}.`);

                if (isPanelRefresh && targetPanelSelectors) {
                    // --- Panel Refresh Logic ---
                    console.log(`Processing panel refresh for targets: ${targetPanelSelectors}`);
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = responseHTML; // Parse the full response

                    // Update notes and state from the hidden fields in the *full* response
                    const newForm = tempDiv.querySelector('#geems-turn-form');
                    if (newForm) {
                        currentTurnNumber = parseInt(newForm.querySelector('input[name="turn"]')?.value || currentTurnNumber + 1, 10);
                        currentSubjectId = newForm.querySelector('input[name="subjectId"]')?.value || currentSubjectId;
                        currentNotes = newForm.querySelector('input[name="notes"]')?.value || currentNotes;
                        console.log(`State Updated during panel refresh: Turn=${currentTurnNumber}, Subject=${currentSubjectId}, Notes Length=${currentNotes.length}`);
                    } else {
                        console.warn("No form found in panel refresh response to update state.");
                        currentTurnNumber++; // Increment turn anyway
                    }


                    // Selectively update target panels
                    const selectors = targetPanelSelectors.split(',').map(s => s.trim()).filter(s => s);
                    let updatedCount = 0;
                    selectors.forEach(selector => {
                        const newPanelContent = tempDiv.querySelector(selector);
                        const currentPanel = turnContentContainer.querySelector(selector);
                        if (newPanelContent && currentPanel) {
                            console.log(`Updating panel: ${selector}`);
                            currentPanel.innerHTML = newPanelContent.innerHTML; // Replace content
                            updatedCount++;
                        } else {
                            console.warn(`Panel not found for selective update (current or new): ${selector}`);
                        }
                    });
                    if(updatedCount > 0) {
                        currentTurnHTML = turnContentContainer.innerHTML; // Update stored HTML after partial updates
                        autoSaveGameState(); // Save the partially updated state
                    }
                    attachPanelRefreshListeners(); // Re-attach listeners after update
                    // --- End Panel Refresh Logic ---
                } else {
                    // --- Full Refresh Logic ---
                    processSuccessfulResponse(responseHTML, playerActionsJson);
                    // --- End Full Refresh Logic ---
                }

                success = true;
                currentAttemptConsecutiveErrors = 0;
            } catch (error) {
                // Error handling and model switching (same as before)
                console.error(`Error with model ${currentModel} (Attempt ${attempts}):`, error);
                currentAttemptConsecutiveErrors++;
                const isQuotaError = error.message.includes('429') || /quota exceeded|resource.*exhausted/i.test(error.message);
                const shouldSwitch = isQuotaError || currentAttemptConsecutiveErrors >= 2;
                if (shouldSwitch && AVAILABLE_MODELS.length > 1) {
                    const oldModel = AVAILABLE_MODELS[currentModelIndex];
                    currentModelIndex = (currentModelIndex + 1) % AVAILABLE_MODELS.length;
                    const newModel = AVAILABLE_MODELS[currentModelIndex];
                    console.warn(`Switching model from ${oldModel} to ${newModel} due to ${isQuotaError ? 'quota/resource error' : '2 errors'}.`);
                    showError(`Experiencing issues with ${oldModel}. Trying ${newModel}... (Attempt ${attempts + 1})`);
                    currentAttemptConsecutiveErrors = 0;
                } else if (attempts < maxAttempts) {
                    showError(`Temporary issue with ${currentModel}. Retrying... (Attempt ${attempts + 1})`);
                }
                if (!success && attempts < maxAttempts) await new Promise(resolve => setTimeout(resolve, 750));
            }
        }

        if (!success) {
            console.error(`Failed after ${maxAttempts} attempts.`);
            showError(`Failed to get response after ${maxAttempts} attempts. Check API key, network, or try later.`);
            // Optionally revert UI or show persistent error
            if(isPanelRefresh) {
                // Maybe revert the triggering input? Or just leave as is.
                console.warn("Panel refresh failed after all attempts.");
            } else {
                turnContentContainer.innerHTML = `<div class="error-message">Session failed to load after multiple attempts. Please check your connection or API key and try resetting.</div>`;
            }
        } else {
            hideError(); // Clear error message on success
            if (!isPanelRefresh) { // Only scroll on full refresh
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }
        setLoading(false); // Turn off loading indicator
    }

    /** Calls the real Google AI (Gemini) API. */
    async function callRealGeminiAPI(apiKey, promptText, modelName) {
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
        // Requesting plain text, expecting HTML content within
        const requestBody = {
            contents: [{ parts: [{ text: promptText }] }],
            generationConfig: { temperature: 1.0, response_mime_type: "text/plain" },
            safetySettings: [ // Keep BLOCK_NONE for exploration
                { "category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE" },
                { "category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE" },
                { "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE" },
                { "category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE" }
            ]
        };

        console.log(`Sending API request to: ${modelName}`);
        const response = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            // ... (error handling as before) ...
            let errorBody = `API request failed (${response.status})`;
            try {
                const errorJson = await response.json();
                errorBody += `: ${JSON.stringify(errorJson.error || errorJson)}`;
            } catch (e) {
                try { errorBody += `: ${await response.text()}`; } catch (e2) {}
            }
            console.error("API Error:", errorBody);
            throw new Error(errorBody);
        }

        const responseData = await response.json();

        // --- Safety/Content Checks ---
        if (responseData.promptFeedback && responseData.promptFeedback.blockReason) {
            throw new Error(`Request blocked by API. Reason: ${responseData.promptFeedback.blockReason}. Details: ${JSON.stringify(responseData.promptFeedback.safetyRatings || 'N/A')}`);
        }
        if (!responseData.candidates || responseData.candidates.length === 0) {
            // Handle case where response might be string instead of object (less likely for HTML)
            if (typeof responseData === 'string') {
                // Check if the string looks like HTML before returning
                if (responseData.trim().startsWith('<') && responseData.trim().endsWith('>')) {
                    return responseData.trim();
                } else {
                    throw new Error('No candidates, response was unexpected string format.');
                }
            }
            throw new Error('No candidates or unexpected API response structure.');
        }

        const candidate = responseData.candidates[0];

        // Check finish reason and safety ratings
        if (candidate.finishReason && !["STOP", "MAX_TOKENS"].includes(candidate.finishReason)) {
            const reason = `API Finish Reason: ${candidate.finishReason}. Safety Ratings: ${JSON.stringify(candidate.safetyRatings || 'N/A')}`;
            console.warn(reason + " (Content might be incomplete or filtered)");
            // If blocked by SAFETY, still check if *any* content was returned
            if (candidate.finishReason === "SAFETY" && (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0 || !candidate.content.parts[0].text)) {
                throw new Error(`Request blocked by API censorship (content). Reason: SAFETY.`);
            } else if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
                // If finished for other non-STOP reason and no content, throw error
                throw new Error(reason + " (No content returned)");
            }
            // Otherwise, proceed with potentially partial content
        }

        // Check for missing content parts even if finishReason is STOP
        if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0 || !candidate.content.parts[0].text) {
            // Allow empty response if blocked by safety, otherwise throw error
            if(candidate.finishReason === "SAFETY") {
                console.warn("API response blocked by SAFETY, returning empty string.");
                return ""; // Return empty string for safety blocks with no content
            }
            console.error("API candidate generated but no valid content part found:", candidate);
            throw new Error('API candidate generated but no valid text content found.');
        }

        // --- Extract HTML ---
        let htmlContent = candidate.content.parts[0].text;
        const trimmedContent = htmlContent.trim();

        // Handle potential Markdown wrapping ```html ... ```
        const markdownMatch = trimmedContent.match(/^```(?:html)?\s*([\s\S]*?)\s*```$/);
        if (markdownMatch && markdownMatch[1]) {
            console.log("Extracted HTML from markdown block.");
            htmlContent = markdownMatch[1].trim();
        } else if (!trimmedContent.startsWith('<') || !trimmedContent.endsWith('>')) {
            // Basic check if it looks like HTML at all
            console.warn(`API response might not be valid HTML. Snippet: ${trimmedContent.substring(0, 100)}...`);
            // Return it anyway, let the browser try to parse
            htmlContent = trimmedContent;
        } else {
            htmlContent = trimmedContent; // Assume it's HTML
        }

        return htmlContent;
    }

    /** Collects input state from the current form within #turn-content */
    function collectInputState() {
        const inputs = {};
        const form = turnContentContainer.querySelector('#geems-turn-form'); // Target the specific form

        if (!form) {
            console.warn("Could not find #geems-turn-form to collect input.");
            // Return minimal state if no form found (e.g., for first turn)
            return JSON.stringify({ turn: currentTurnNumber, subjectId: currentSubjectId });
        }

        const formData = new FormData(form);

        for (const [key, value] of formData.entries()) {
            // Handle checkboxes - they only appear in FormData if checked
            const element = form.querySelector(`[name="${key}"][type="checkbox"]`);
            if (element) {
                // We need to know if *any* checkbox with this name exists
                // If it's in formData, it's checked (value is usually 'on' or the value attribute)
                inputs[key] = true;
            } else {
                // Handle other input types (radio, text, range, hidden)
                // For radio buttons, only the selected one appears in FormData
                inputs[key] = value;
            }
        }

        // Ensure unchecked checkboxes are recorded as false
        form.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            if (!inputs.hasOwnProperty(cb.name)) {
                inputs[cb.name] = false;
            }
        });

        console.log("Collected form data:", inputs);

        // Add turn number if not present in form (should be)
        if (!inputs.hasOwnProperty('turn')) {
            inputs.turn = currentTurnNumber;
        }
        // Add subjectId if not present in form (should be)
        if (!inputs.hasOwnProperty('subjectId')) {
            inputs.subjectId = currentSubjectId;
        }

        // IMPORTANT: Remove the 'notes' field before sending back to LLM
        // The LLM receives the notes separately in the prompt construction.
        delete inputs.notes;

        return JSON.stringify(inputs);
    }

    /** Sets the loading state and disables/enables UI elements. */
    function setLoading(loading, isPanelRefresh = false) {
        isLoading = loading;
        loadingIndicator.style.display = loading ? 'flex' : 'none';
        const keyPresent = apiKeyInput.value.trim().length > 0;

        // Disable global buttons based on overall loading state
        nextTurnButton.disabled = loading || !(apiKeyLocked || keyPresent);
        resetGameButton.disabled = loading || !apiKeyLocked; // Allow reset even if loading? Maybe not.
        apiKeyInput.disabled = loading || apiKeyLocked;

        // Dim/disable elements within the turn content during any loading
        const form = turnContentContainer.querySelector('#geems-turn-form');
        if (form) {
            form.style.opacity = loading ? 0.5 : 1.0;
            form.style.pointerEvents = loading ? 'none' : 'auto';
            form.querySelectorAll('input, textarea, button, select').forEach(el => {
                // Don't disable the main next turn button if it's somehow inside
                if (el.id !== 'next-turn-button') {
                    el.disabled = loading;
                }
            });
        }

        // Specifically re-enable the main button if only a panel refresh finished
        if (!loading && isPanelRefresh) {
            nextTurnButton.disabled = !(apiKeyLocked || keyPresent);
        }
    }

    /** Displays an error message. */
    function showError(message) {
        errorDisplay.textContent = message;
        errorDisplay.style.display = 'block';
    }

    /** Hides the error message. */
    function hideError() {
        errorDisplay.textContent = '';
        errorDisplay.style.display = 'none';
    }

    /** Sets the header banner image dynamically. */
    function setDynamicHeaderImage() {
        const headerSeed = Math.floor(Math.random() * 65536);
        // More abstract/thematic prompt for GEEMS
        const headerPrompt = "wide cinematic abstract representation of neural pathways glowing energy synapses";
        if (headerBanner) {
            headerBanner.src = `${POLLINATIONS_URL_BASE}${encodeURIComponent(headerPrompt)}?width=1200&height=150&seed=${headerSeed}&nologo=true&safe=false`;
            headerBanner.alt = headerPrompt;
            headerBanner.onerror = () => { // Fallback
                headerBanner.src = `https://placehold.co/1200x150/374151/e5e7eb?text=GEEMS`;
                headerBanner.alt = "GEEMS Header Fallback";
            };
        }
    }

    /** Attaches event listeners for panel refresh triggers using event delegation */
    function attachPanelRefreshListeners() {
        console.log("Attaching panel refresh listeners to #game-container");
        // Remove previous listener to avoid duplicates if re-attaching
        gameContainer.removeEventListener('change', handlePanelTrigger);
        // Add new listener
        gameContainer.addEventListener('change', handlePanelTrigger);
    }

    /** Handles clicks that trigger panel refreshes */
    function handlePanelTrigger(event) {
        const target = event.target;
        // Check if the changed element has the trigger attribute
        if (target.matches('[data-trigger-action="refreshPanel"]')) {
            event.preventDefault(); // Prevent default form submission if applicable
            console.log("Panel refresh triggered by:", target);

            const targetPanelSelectors = target.dataset.targetPanels;
            const inputName = target.dataset.inputName; // Get the name of the input that triggered this

            if (!targetPanelSelectors || !inputName) {
                console.warn("Panel refresh trigger missing target panels or input name metadata.");
                return;
            }

            // Collect the current state of the *entire* form
            const playerActionsJson = collectInputState();

            // Call fetchTurnData, indicating it's a panel refresh
            fetchTurnData(playerActionsJson, true, targetPanelSelectors);
        }
    }


    // --- Initial Game Setup ---
    function initializeGame() {
        console.log("Initializing GEEMS LLM UI...");
        let autoStarted = false;
        const storedStateString = localStorage.getItem(LOCAL_STORAGE_KEY);

        // --- State Restoration ---
        if (storedStateString) {
            console.log("Found saved state. Attempting restore...");
            let savedState;
            try {
                savedState = JSON.parse(storedStateString);
                const decodedApiKey = decodeApiKey(savedState.encodedApiKey);
                if (!decodedApiKey) throw new Error("Failed to decode API key.");

                apiKeyInput.value = decodedApiKey;
                currentTurnHTML = savedState.currentTurnHTML || null;
                currentNotes = savedState.currentNotes || "";
                currentTurnNumber = savedState.currentTurnNumber || 0;
                currentSubjectId = savedState.currentSubjectId || "SubjectRestore";
                currentModelIndex = savedState.currentModelIndex || 0;

                if (currentTurnHTML && currentTurnNumber > 0) {
                    apiKeyLocked = true;
                    autoStarted = true;
                    console.log("State restored from localStorage. Turn:", currentTurnNumber);
                    setDynamicHeaderImage();
                    turnContentContainer.innerHTML = currentTurnHTML; // Render saved HTML
                    attachPanelRefreshListeners(); // Attach listeners to restored content
                    updateModeButtonVisuals(); // Update any mode buttons if applicable
                    apiKeySection.style.display = 'none';
                    const msg = document.getElementById('initial-message');
                    if (msg) msg.style.display = 'none';
                    hideError();
                    setLoading(false);
                    nextTurnButton.textContent = `Next Turn (${currentTurnNumber})`;
                    nextTurnButton.disabled = false;
                    resetGameButton.disabled = false;
                } else {
                    throw new Error("Restored state incomplete (missing UI or turn 0).");
                }
            } catch (error) {
                // ... (error handling as before) ...
                console.error("Error restoring state:", error);
                showError(`Error restoring saved state: ${error.message}. Start manually.`);
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                // Reset state variables
                currentTurnHTML = null; currentNotes = ""; currentTurnNumber = 0; currentSubjectId = "SubjectZero";
                currentModelIndex = 0; apiKeyLocked = false; autoStarted = false;
                apiKeyInput.value = '';
                turnContentContainer.innerHTML = ''; // Clear content
                const initialMsg = document.getElementById('initial-message') || createInitialMessageElement(); // Create if needed
                initialMsg.style.display = 'block';
                initialMsg.innerHTML = 'Error restoring. Enter API Key';
                if (apiKeySection) apiKeySection.style.display = 'block';
                setLoading(false);
                setDynamicHeaderImage();
                nextTurnButton.textContent = 'Start Session / Next Turn';
                nextTurnButton.disabled = true;
                resetGameButton.disabled = true;
            }
        }

        // --- URL Parameter Handling ---
        if (!autoStarted) {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const keyFromUrlParam = urlParams.get('apiKey');
                if (keyFromUrlParam) {
                    console.log("API Key from URL. Auto-starting...");
                    apiKeyInput.value = keyFromUrlParam;
                    apiKeyLocked = false; // Needs first turn to lock
                    currentModelIndex = 0;
                    currentTurnHTML = null; currentNotes = ""; currentTurnNumber = 0; currentSubjectId = "SubjectURL";

                    if (apiKeySection) apiKeySection.style.display = 'none';
                    const msg = document.getElementById('initial-message') || createInitialMessageElement();
                    msg.style.display = 'none';

                    // Clean URL
                    const currentUrl = new URL(window.location.href);
                    currentUrl.searchParams.delete('apiKey');
                    window.history.replaceState(null, '', currentUrl.toString());

                    setDynamicHeaderImage();
                    // Fetch Turn 1
                    fetchTurnData(JSON.stringify({ turn: 0, subjectId: currentSubjectId })); // Send minimal initial actions
                    autoStarted = true;
                    setLoading(true); // Set loading for the first fetch
                    nextTurnButton.textContent = "Loading...";
                    nextTurnButton.disabled = true;
                    resetGameButton.disabled = true; // Disable reset until locked
                }
            } catch (e) {
                console.error("Error processing URL params:", e);
                showError("Error reading URL params. Start manually.");
                autoStarted = false; // Ensure manual start if URL params fail
            }
        }


        // --- Manual Start Fallback ---
        if (!autoStarted) {
            console.log("Manual start required.");
            // Reset state variables
            currentTurnHTML = null; currentNotes = ""; currentTurnNumber = 0; currentSubjectId = "SubjectZero";
            currentModelIndex = 0; apiKeyLocked = false;
            turnContentContainer.innerHTML = ''; // Clear content
            const initialMsg = document.getElementById('initial-message') || createInitialMessageElement();
            initialMsg.style.display = 'block';
            initialMsg.innerHTML = 'Enter API Key and click "Start Session / Next Turn"';
            if (apiKeySection) apiKeySection.style.display = 'block';
            // Don't clear API key if user might have typed it
            // apiKeyInput.value = '';
            setLoading(false);
            hideError();
            setDynamicHeaderImage();
            nextTurnButton.textContent = 'Start Session / Next Turn';
            nextTurnButton.disabled = apiKeyInput.value.trim().length === 0; // Disable if key empty
            resetGameButton.disabled = true; // Disable reset until locked
        }
    }

    /** Creates the initial message element if it doesn't exist */
    function createInitialMessageElement() {
        let msgDiv = document.getElementById('initial-message');
        if (!msgDiv) {
            msgDiv = document.createElement('div');
            msgDiv.id = 'initial-message';
            msgDiv.className = 'text-center text-gray-500 p-6';
            // Prepend to turnContentContainer so it's there if needed
            turnContentContainer.prepend(msgDiv);
        }
        return msgDiv;
    }


    // --- Event Listeners ---

    // Main button for full turn progression
    nextTurnButton.addEventListener('click', () => {
        if (!nextTurnButton.disabled && !isLoading) {
            console.log("Next Turn button clicked.");
            initAudioContext(); // Ensure audio is ready
            const playerActions = collectInputState(); // Collect state from the *current* UI
            fetchTurnData(playerActions); // Fetch the *next* turn's full UI
        }
    });

    // API Key Input Listener
    apiKeyInput.addEventListener('input', () => {
        const keyPresent = apiKeyInput.value.trim().length > 0;
        // Enable Next Turn button only if key is present and not already locked/loading
        nextTurnButton.disabled = isLoading || !(apiKeyLocked || keyPresent);
        // Reset button enabled only if key is present OR game is locked
        resetGameButton.disabled = isLoading || !(apiKeyLocked || keyPresent);

        // Update initial message visibility/text if API key section is visible
        if (apiKeySection && apiKeySection.style.display !== 'none') {
            const msg = document.getElementById('initial-message');
            if (msg && msg.style.display !== 'none') {
                if (keyPresent) {
                    hideError(); // Hide errors when user starts typing key
                    msg.textContent = 'API Key entered. Click "Start Session / Next Turn" to begin!';
                } else {
                    msg.innerHTML = 'Enter API Key and click "Start Session / Next Turn"';
                }
            }
        }
    });

    // Reset Button Listener
    resetGameButton.addEventListener('click', () => {
        if (isLoading || resetGameButton.disabled) return;
        if (confirm('Reset session? This will clear your current progress in this browser.')) {
            console.log("Resetting game state...");
            // Reset variables
            historyQueue = [];
            currentTurnHTML = null;
            currentNotes = "";
            currentTurnNumber = 0;
            currentSubjectId = "SubjectZero";
            currentModelIndex = 0;
            apiKeyLocked = false;

            localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear saved state
            console.log("Cleared localStorage.");

            // Reset UI
            turnContentContainer.innerHTML = '';
            hideError();
            if (apiKeySection) apiKeySection.style.display = 'block'; // Show API key section again
            const initialMsg = document.getElementById('initial-message') || createInitialMessageElement();
            initialMsg.style.display = 'block';
            initialMsg.innerHTML = 'Enter API Key and click "Start Session / Next Turn"';

            const keyPresent = apiKeyInput.value.trim().length > 0;
            setLoading(false);
            nextTurnButton.textContent = 'Start Session / Next Turn';
            nextTurnButton.disabled = !keyPresent; // Disable if key is empty now
            resetGameButton.disabled = !keyPresent; // Disable if key is empty now
            setDynamicHeaderImage(); // Reset header image
        }
    });

    // --- Initialize ---
    document.addEventListener('DOMContentLoaded', initializeGame);

</script>

</body>
</html>